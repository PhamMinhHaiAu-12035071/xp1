import 'package:get_it/get_it.dart';
import 'package:injectable/injectable.dart';
import 'package:xp1/core/infrastructure/logging/i_logger_service.dart';

// Import will be generated by build_runner
import 'injection_container.config.dart';

/// Global service locator instance
final GetIt getIt = GetIt.instance;

// Global state removed - now using proper GetIt state checking
// This eliminates the anti-pattern identified in code review

/// Exception thrown when dependency injection initialization fails.
class DependencyInjectionException implements Exception {
  /// Creates a dependency injection exception with the given error.
  const DependencyInjectionException(this.originalError);

  /// The original error that caused the dependency injection failure.
  final Object originalError;

  @override
  String toString() =>
      'DependencyInjectionException: Failed to initialize dependency '
      'injection: $originalError';
}

/// Configures dependency injection for the application.
///
/// Uses proper GetIt state checking instead of global flags.
/// This follows clean architecture principles and eliminates
/// the anti-pattern of global mutable state.
@InjectableInit()
Future<void> configureDependencies() async {
  try {
    // Use GetIt's built-in state checking instead of external flags
    // Check for a known service to determine if already configured
    if (getIt.isRegistered<ILoggerService>()) {
      // Dependencies already configured, skip initialization
      return;
    }

    await getIt.init();
  } catch (e) {
    // Specific error handling for DI initialization
    throw DependencyInjectionException(e);
  }
}

// resetDependencyConfiguration function removed
// Tests should use getIt.reset() directly when needed
// This eliminates the need for additional global state management
