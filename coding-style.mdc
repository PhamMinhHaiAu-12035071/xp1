# Dart Coding Style Guidelines

## üö® Critical Rules to Prevent Linter Errors

> **ZERO TOLERANCE POLICY**: No linting errors, no warnings, no exceptions. Every issue must be resolved before commit.

**Priority Order for Quick Fixes:**

1. üî• **cascade_invocations** - Use `..` for instance methods, records `()` for static methods
2. üî• **public_member_api_docs** - Add `/// documentation` to all public APIs
3. üî• **lines_longer_than_80_chars** - Break long lines immediately
4. üî• **prefer_const_constructors** - Add `const` wherever possible
5. üî• **avoid_print** - Replace with `Console.info()` or proper logging

## üèóÔ∏è Navigation & Auto Route Patterns

### Route Configuration

```dart
// ‚úÖ CORRECT: Type-safe route configuration
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(
      page: LoginRoute.page,
      path: '/login',
      initial: true,
    ),
    AutoRoute(
      page: MainWrapperRoute.page,
      path: '/main',
      children: [
        AutoRoute(page: HomeRoute.page, path: 'home'),
        AutoRoute(page: ProfileRoute.page, path: 'profile'),
      ],
    ),
  ];
}
```

### Navigation Usage

```dart
// ‚úÖ CORRECT: Type-safe navigation
context.router.push(const HomeRoute());
context.router.pushAndClearStack(const LoginRoute());
context.router.replaceAll([const MainWrapperRoute()]);

// ‚ùå AVOID: String-based navigation
Navigator.pushNamed(context, '/home');
```

### Route Guards Implementation

```dart
// ‚úÖ CORRECT: Authentication guard
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    if (isAuthenticated) {
      resolver.next();
    } else {
      router.pushAndClearStack(const LoginRoute());
    }
  }
}

// ‚úÖ CORRECT: Guard registration
@override
List<AutoRouteGuard> get guards => [AuthGuard()];
```

### Navigation Data Structures (Linus Principle)

```dart
// ‚úÖ CORRECT: Eliminate special cases with data structures
class NavTabConfig {
  const NavTabConfig({
    required this.route,
    required this.icon,
    required this.label,
  });

  final PageRouteInfo route;
  final IconData icon;
  final String label;
}

// Single source of truth for navigation
static const List<NavTabConfig> _navTabs = [
  NavTabConfig(route: HomeRoute(), icon: Icons.home, label: 'Home'),
  NavTabConfig(route: ProfileRoute(), icon: Icons.person, label: 'Profile'),
];

// Generate both routes and bottom nav from same data
routes: _navTabs.map((tab) => tab.route).toList(),
items: _navTabs.map((tab) => BottomNavigationBarItem(
  icon: Icon(tab.icon),
  label: tab.label,
)).toList(),
```

## üß™ Testing Patterns & PageTestHelpers

### DRY Principle for Page Testing

```dart
// ‚úÖ CORRECT: Use PageTestHelpers to eliminate duplication
void main() {
  group('HomePage', () {
    PageTestHelpers.testStandardPage<HomePage>(
      const HomePage(),
      'Hello World - Home',
      () => const HomePage(),
      (key) => HomePage(key: key),
    );
  });
}

// ‚úÖ CORRECT: Comprehensive testing with navigation
void main() {
  group('AttendancePage', () {
    PageTestHelpers.testComprehensivePage<AttendancePage>(
      const AttendancePage(),
      'Hello World - Attendance',
      () => const AttendancePage(),
      (key) => AttendancePage(key: key),
      pageRoute: '/main/attendance',
    );
  });
}

// ‚ùå AVOID: Code duplication (violates DRY)
group('ProfilePage', () {
  testWidgets('should render ProfilePage widget', (tester) async {
    await tester.pumpApp(const ProfilePage());
    expect(find.byType(ProfilePage), findsOneWidget);
  });

  testWidgets('should render Scaffold', (tester) async {
    await tester.pumpApp(const ProfilePage());
    expect(find.byType(Scaffold), findsOneWidget);
  });
  // ... 20+ more duplicate tests
});
```

### Navigation Testing Patterns

```dart
// ‚úÖ CORRECT: Router-enabled testing
testWidgets('should navigate to main when login succeeds', (tester) async {
  await tester.pumpAppWithRouter(const SizedBox());
  await tester.pumpAndSettle();

  final loginButton = find.byType(ElevatedButton);
  await tester.tap(loginButton);
  await tester.pumpAndSettle();

  expect(find.byType(LoginPage), findsNothing);
});

// ‚úÖ CORRECT: Route guard testing
testWidgets('should redirect unauthorized users', (tester) async {
  // Test authentication flow
});
```

### Test Helper Pattern Implementation

```dart
// ‚úÖ CORRECT: Memory management and environment setup
class PageTestHelpers {
  static void testEnvironmentSetup() {
    group('Environment Setup Tests', () {
      setUpAll(() async {
        await TestDependencyContainer.setupTestDependencies();
      });

      tearDownAll(() async {
        await TestDependencyContainer.resetTestDependencies();
      });
    });
  }
}
```

## 1. Cascade Operators (`..`) - MANDATORY for Multiple Calls

**THE GOLDEN RULE:** Use cascade operators when calling 2+ methods on the same object instance.

```dart
// ‚ùå LINT ERROR: cascade_invocations
final logger = Logger(printer: SimplePrinter());
logger.e('Error message 1');
logger.e('Error message 2');
logger.e('Error message 3');

// ‚úÖ CORRECT: Use cascade operators
Logger(printer: SimplePrinter())
  ..e('Error message 1')
  ..e('Error message 2')
  ..e('Error message 3');

// ‚ùå SPECIAL CASE: Static methods (cascade won't work)
EnvConfigFactory.apiUrl;
EnvConfigFactory.appName;
EnvConfigFactory.environmentName;

// ‚úÖ SOLUTION: Use records for grouping static calls
final _ = (
  EnvConfigFactory.apiUrl,
  EnvConfigFactory.appName,
  EnvConfigFactory.environmentName,
);
```

## 2. Documentation - MANDATORY for Public APIs

**ALL public members MUST have documentation** to avoid `public_member_api_docs` errors.

```dart
// ‚ùå LINT ERROR: Missing documentation
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [];
}

// ‚úÖ CORRECT: Document all public APIs
/// Application router configuration using AutoRoute.
///
/// Provides type-safe navigation with route guards and nested routes.
/// Implements authentication flow and bottom navigation structure.
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  RouteType get defaultRouteType => const RouteType.adaptive();

  /// Global guards for route protection.
  @override
  List<AutoRouteGuard> get guards => [AuthGuard()];

  @override
  List<AutoRoute> get routes => [
    // Route definitions
  ];
}
```

### Navigation Documentation Templates

```dart
// ‚úÖ ROUTE GUARD DOCUMENTATION
/// Authentication guard for protecting routes.
///
/// Ensures users are authenticated before accessing protected pages.
/// Redirects unauthenticated users to login page automatically.
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    // Implementation
  }
}

// ‚úÖ PAGE DOCUMENTATION
/// Home page showing main dashboard content.
///
/// Displays user dashboard with navigation to other features.
/// Accessible after successful authentication.
@RoutePage()
class HomePage extends StatelessWidget {
  /// Creates a home page.
  const HomePage({super.key});
}

// ‚úÖ TEST HELPER DOCUMENTATION
/// Test helpers for page testing to eliminate code duplication.
///
/// Provides reusable test functions following Linus's principle:
/// "Good programmers worry about data structures and their relationships."
/// These helpers eliminate special cases and reduce test complexity.
class PageTestHelpers {
  /// Tests standard page structure with comprehensive coverage.
  ///
  /// [page] The page widget to test.
  /// [expectedText] The text that should be displayed.
  /// [createWidget] Function to create widget without key.
  /// [createWidgetWithKey] Function to create widget with key.
  static void testStandardPage<T extends Widget>(
    T page,
    String expectedText,
    T Function() createWidget,
    T Function(Key key) createWidgetWithKey,
  ) {
    // Implementation
  }
}
```

## üîß Navigation Commands & Code Generation

### Required Commands After Route Changes

```bash
# Generate route files after changing @RoutePage() annotations
dart run build_runner build --delete-conflicting-outputs

# Watch for auto-generation during development
dart run build_runner watch

# Clean build cache if conflicts occur
dart run build_runner clean
```

### Integration with Development Workflow

```bash
# After adding new routes/pages
dart run build_runner build
dart run rps format
dart run rps analyze
flutter test
```

## üéØ Performance & Memory Management

### Route Guard Performance

```dart
// ‚úÖ CORRECT: Efficient guard implementation
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    // Quick authentication check - no async operations
    if (_authService.isAuthenticated) {
      resolver.next();
    } else {
      resolver.redirectUntil(const LoginRoute());
    }
  }
}

// ‚ùå AVOID: Heavy operations in guards
class BadAuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) async {
    // ‚ùå Don't make API calls in guards
    final isAuth = await authApi.checkToken();
    // This blocks navigation
  }
}
```

### Navigation Memory Management

```dart
// ‚úÖ CORRECT: Proper disposal in navigation
class MainWrapperPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AutoTabsScaffold(
      routes: _navTabs.map((tab) => tab.route).toList(),
      // Proper memory cleanup handled by AutoRoute
    );
  }
}
```

## üö® Navigation Anti-Patterns

### What NOT to Do

```dart
// ‚ùå AVOID: Manual route management
class BadNavigationPage extends StatefulWidget {
  @override
  State<BadNavigationPage> createState() => _BadNavigationPageState();
}

class _BadNavigationPageState extends State<BadNavigationPage> {
  int _currentIndex = 0;

  final List<Widget> _pages = [
    HomePage(),  // ‚ùå No const, memory leaks
    ProfilePage(),  // ‚ùå Creating widgets in list
  ];

  // ‚ùå Manual navigation logic
  void _onTap(int index) {
    setState(() {
      _currentIndex = index;
    });
  }
}

// ‚ùå AVOID: String-based navigation
Navigator.pushNamed(context, '/profile');
Navigator.pushReplacementNamed(context, '/home');

// ‚ùå AVOID: Direct instantiation
Navigator.push(context, MaterialPageRoute(
  builder: (context) => ProfilePage(),  // ‚ùå No type safety
));
```

## üìã Quick Reference: Navigation Patterns

| **Pattern**              | **Auto Route Solution**                       | **Benefits**              |
| ------------------------ | --------------------------------------------- | ------------------------- |
| **Type-safe navigation** | `context.router.push(const HomeRoute())`      | Compile-time safety       |
| **Route guards**         | `AuthGuard extends AutoRouteGuard`            | Centralized protection    |
| **Nested routes**        | `children: [AutoRoute(page: HomeRoute.page)]` | Clean organization        |
| **Bottom navigation**    | `AutoTabsScaffold(routes: [...])`             | Built-in state management |
| **Testing navigation**   | `tester.pumpAppWithRouter()`                  | Router-enabled testing    |

## üèÜ Navigation Best Practices Summary

1. **Always use Auto Route** for type-safe navigation
2. **Document all route-related classes** with comprehensive `///` comments
3. **Use PageTestHelpers** to eliminate test duplication
4. **Implement route guards** for authentication and authorization
5. **Test navigation flows** with router-enabled testing
6. **Follow data structure patterns** to eliminate special cases
7. **Generate routes after changes** with `dart run build_runner build`
8. **Keep guards lightweight** - no heavy async operations

Following these navigation patterns ensures scalable, maintainable, and well-tested navigation throughout the application.
