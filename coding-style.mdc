# Dart Coding Style Guidelines

## üö® Critical Rules to Prevent Linter Errors

> **ZERO TOLERANCE POLICY**: No linting errors, no warnings, no exceptions. Every issue must be resolved before commit.

**Priority Order for Quick Fixes:**

1. üî• **cascade_invocations** - Use `..` for instance methods, records `()` for static methods
2. üî• **public_member_api_docs** - Add `/// documentation` to all public APIs
3. üî• **lines_longer_than_80_chars** - Break long lines immediately
4. üî• **prefer_const_constructors** - Add `const` wherever possible
5. üî• **avoid_print** - Replace with `Console.info()` or proper logging
6. üî• **no_adjacent_strings_in_list** - Extract long strings to variables
7. üî• **avoid_equals_and_hash_code_on_mutable_classes** - Use @immutable annotation
8. üî• **prefer_const_literals_to_create_immutables** - Use const literals in @immutable classes

## üèóÔ∏è Navigation & Auto Route Patterns

### Route Configuration

```dart
// ‚úÖ CORRECT: Type-safe route configuration
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(
      page: LoginRoute.page,
      path: '/login',
      initial: true,
    ),
    AutoRoute(
      page: MainWrapperRoute.page,
      path: '/main',
      children: [
        AutoRoute(page: HomeRoute.page, path: 'home'),
        AutoRoute(page: ProfileRoute.page, path: 'profile'),
      ],
    ),
  ];
}
```

### Navigation Usage

```dart
// ‚úÖ CORRECT: Type-safe navigation
context.router.push(const HomeRoute());
context.router.pushAndClearStack(const LoginRoute());
context.router.replaceAll([const MainWrapperRoute()]);

// ‚ùå AVOID: String-based navigation
Navigator.pushNamed(context, '/home');
```

### Route Guards Implementation

```dart
// ‚úÖ CORRECT: Authentication guard
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    if (isAuthenticated) {
      resolver.next();
    } else {
      router.pushAndClearStack(const LoginRoute());
    }
  }
}

// ‚úÖ CORRECT: Guard registration
@override
List<AutoRouteGuard> get guards => [AuthGuard()];
```

### Navigation Data Structures (Linus Principle)

```dart
// ‚úÖ CORRECT: Eliminate special cases with data structures
class NavTabConfig {
  const NavTabConfig({
    required this.route,
    required this.icon,
    required this.label,
  });

  final PageRouteInfo route;
  final IconData icon;
  final String label;
}

// Single source of truth for navigation
static const List<NavTabConfig> _navTabs = [
  NavTabConfig(route: HomeRoute(), icon: Icons.home, label: 'Home'),
  NavTabConfig(route: ProfileRoute(), icon: Icons.person, label: 'Profile'),
];

// Generate both routes and bottom nav from same data
routes: _navTabs.map((tab) => tab.route).toList(),
items: _navTabs.map((tab) => BottomNavigationBarItem(
  icon: Icon(tab.icon),
  label: tab.label,
)).toList(),
```

## üß™ Testing Patterns & PageTestHelpers

### DRY Principle for Page Testing

```dart
// ‚úÖ CORRECT: Use PageTestHelpers to eliminate duplication
void main() {
  group('HomePage', () {
    PageTestHelpers.testStandardPage<HomePage>(
      const HomePage(),
      'Hello World - Home',
      () => const HomePage(),
      (key) => HomePage(key: key),
    );
  });
}

// ‚úÖ CORRECT: Comprehensive testing with navigation
void main() {
  group('AttendancePage', () {
    PageTestHelpers.testComprehensivePage<AttendancePage>(
      const AttendancePage(),
      'Hello World - Attendance',
      () => const AttendancePage(),
      (key) => AttendancePage(key: key),
      pageRoute: '/main/attendance',
    );
  });
}

// ‚ùå AVOID: Code duplication (violates DRY)
group('ProfilePage', () {
  testWidgets('should render ProfilePage widget', (tester) async {
    await tester.pumpApp(const ProfilePage());
    expect(find.byType(ProfilePage), findsOneWidget);
  });

  testWidgets('should render Scaffold', (tester) async {
    await tester.pumpApp(const ProfilePage());
    expect(find.byType(Scaffold), findsOneWidget);
  });
  // ... 20+ more duplicate tests
});
```

### Navigation Testing Patterns

```dart
// ‚úÖ CORRECT: Router-enabled testing
testWidgets('should navigate to main when login succeeds', (tester) async {
  await tester.pumpAppWithRouter(const SizedBox());
  await tester.pumpAndSettle();

  final loginButton = find.byType(ElevatedButton);
  await tester.tap(loginButton);
  await tester.pumpAndSettle();

  expect(find.byType(LoginPage), findsNothing);
});

// ‚úÖ CORRECT: Route guard testing
testWidgets('should redirect unauthorized users', (tester) async {
  // Test authentication flow
});
```

### Test Helper Pattern Implementation

```dart
// ‚úÖ CORRECT: Memory management and environment setup
class PageTestHelpers {
  static void testEnvironmentSetup() {
    group('Environment Setup Tests', () {
      setUpAll(() async {
        await TestDependencyContainer.setupTestDependencies();
      });

      tearDownAll(() async {
        await TestDependencyContainer.resetTestDependencies();
      });
    });
  }
}
```

## 1. Cascade Operators (`..`) - MANDATORY for Multiple Calls

**THE GOLDEN RULE:** Use cascade operators when calling 2+ methods on the same object instance.

```dart
// ‚ùå LINT ERROR: cascade_invocations
final logger = Logger(printer: SimplePrinter());
logger.e('Error message 1');
logger.e('Error message 2');
logger.e('Error message 3');

// ‚úÖ CORRECT: Use cascade operators
Logger(printer: SimplePrinter())
  ..e('Error message 1')
  ..e('Error message 2')
  ..e('Error message 3');

// ‚ùå SPECIAL CASE: Static methods (cascade won't work)
EnvConfigFactory.apiUrl;
EnvConfigFactory.appName;
EnvConfigFactory.environmentName;

// ‚úÖ SOLUTION: Use records for grouping static calls
final _ = (
  EnvConfigFactory.apiUrl,
  EnvConfigFactory.appName,
  EnvConfigFactory.environmentName,
);
```

## 2. Documentation - MANDATORY for Public APIs

**ALL public members MUST have documentation** to avoid `public_member_api_docs` errors.

```dart
// ‚ùå LINT ERROR: Missing documentation
class AppRouter extends RootStackRouter {
  @override
  List<AutoRoute> get routes => [];
}

// ‚úÖ CORRECT: Document all public APIs
/// Application router configuration using AutoRoute.
///
/// Provides type-safe navigation with route guards and nested routes.
/// Implements authentication flow and bottom navigation structure.
@AutoRouterConfig()
class AppRouter extends RootStackRouter {
  @override
  RouteType get defaultRouteType => const RouteType.adaptive();

  /// Global guards for route protection.
  @override
  List<AutoRouteGuard> get guards => [AuthGuard()];

  @override
  List<AutoRoute> get routes => [
    // Route definitions
  ];
}
```

### Navigation Documentation Templates

```dart
// ‚úÖ ROUTE GUARD DOCUMENTATION
/// Authentication guard for protecting routes.
///
/// Ensures users are authenticated before accessing protected pages.
/// Redirects unauthenticated users to login page automatically.
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    // Implementation
  }
}

// ‚úÖ PAGE DOCUMENTATION
/// Home page showing main dashboard content.
///
/// Displays user dashboard with navigation to other features.
/// Accessible after successful authentication.
@RoutePage()
class HomePage extends StatelessWidget {
  /// Creates a home page.
  const HomePage({super.key});
}

// ‚úÖ TEST HELPER DOCUMENTATION
/// Test helpers for page testing to eliminate code duplication.
///
/// Provides reusable test functions following Linus's principle:
/// "Good programmers worry about data structures and their relationships."
/// These helpers eliminate special cases and reduce test complexity.
class PageTestHelpers {
  /// Tests standard page structure with comprehensive coverage.
  ///
  /// [page] The page widget to test.
  /// [expectedText] The text that should be displayed.
  /// [createWidget] Function to create widget without key.
  /// [createWidgetWithKey] Function to create widget with key.
  static void testStandardPage<T extends Widget>(
    T page,
    String expectedText,
    T Function() createWidget,
    T Function(Key key) createWidgetWithKey,
  ) {
    // Implementation
  }
}
```

## üîß Navigation Commands & Code Generation

### Required Commands After Route Changes

```bash
# Generate route files after changing @RoutePage() annotations
dart run build_runner build --delete-conflicting-outputs

# Watch for auto-generation during development
dart run build_runner watch

# Clean build cache if conflicts occur
dart run build_runner clean
```

### Integration with Development Workflow

```bash
# After adding new routes/pages
dart run build_runner build
dart run rps format
dart run rps analyze
flutter test
```

## üéØ Performance & Memory Management

### Route Guard Performance

```dart
// ‚úÖ CORRECT: Efficient guard implementation
class AuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) {
    // Quick authentication check - no async operations
    if (_authService.isAuthenticated) {
      resolver.next();
    } else {
      resolver.redirectUntil(const LoginRoute());
    }
  }
}

// ‚ùå AVOID: Heavy operations in guards
class BadAuthGuard extends AutoRouteGuard {
  @override
  void onNavigation(NavigationResolver resolver, StackRouter router) async {
    // ‚ùå Don't make API calls in guards
    final isAuth = await authApi.checkToken();
    // This blocks navigation
  }
}
```

### Navigation Memory Management

```dart
// ‚úÖ CORRECT: Proper disposal in navigation
class MainWrapperPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return AutoTabsScaffold(
      routes: _navTabs.map((tab) => tab.route).toList(),
      // Proper memory cleanup handled by AutoRoute
    );
  }
}
```

## üö® Navigation Anti-Patterns

### What NOT to Do

```dart
// ‚ùå AVOID: Manual route management
class BadNavigationPage extends StatefulWidget {
  @override
  State<BadNavigationPage> createState() => _BadNavigationPageState();
}

class _BadNavigationPageState extends State<BadNavigationPage> {
  int _currentIndex = 0;

  final List<Widget> _pages = [
    HomePage(),  // ‚ùå No const, memory leaks
    ProfilePage(),  // ‚ùå Creating widgets in list
  ];

  // ‚ùå Manual navigation logic
  void _onTap(int index) {
    setState(() {
      _currentIndex = index;
    });
  }
}

// ‚ùå AVOID: String-based navigation
Navigator.pushNamed(context, '/profile');
Navigator.pushReplacementNamed(context, '/home');

// ‚ùå AVOID: Direct instantiation
Navigator.push(context, MaterialPageRoute(
  builder: (context) => ProfilePage(),  // ‚ùå No type safety
));
```

## üìã Quick Reference: Navigation Patterns

| **Pattern**              | **Auto Route Solution**                       | **Benefits**              |
| ------------------------ | --------------------------------------------- | ------------------------- |
| **Type-safe navigation** | `context.router.push(const HomeRoute())`      | Compile-time safety       |
| **Route guards**         | `AuthGuard extends AutoRouteGuard`            | Centralized protection    |
| **Nested routes**        | `children: [AutoRoute(page: HomeRoute.page)]` | Clean organization        |
| **Bottom navigation**    | `AutoTabsScaffold(routes: [...])`             | Built-in state management |
| **Testing navigation**   | `tester.pumpAppWithRouter()`                  | Router-enabled testing    |

## üèÜ Navigation Best Practices Summary

1. **Always use Auto Route** for type-safe navigation
2. **Document all route-related classes** with comprehensive `///` comments
3. **Use PageTestHelpers** to eliminate test duplication
4. **Implement route guards** for authentication and authorization
5. **Test navigation flows** with router-enabled testing
6. **Follow data structure patterns** to eliminate special cases
7. **Generate routes after changes** with `dart run build_runner build`
8. **Keep guards lightweight** - no heavy async operations

Following these navigation patterns ensures scalable, maintainable, and well-tested navigation throughout the application.

## üö® String Handling - Prevent Adjacent Strings Linter Errors

### no_adjacent_strings_in_list - Extract Long Strings to Variables

**THE RULE:** When creating long strings that exceed 80 characters in list literals, extract them to variables instead of using adjacent string concatenation within the list.

```dart
// ‚ùå LINT ERROR: no_adjacent_strings_in_list
final messages = [
  'Some message',
  'üìè Rules: ${ValidationTypes.minDescriptionLength}-'
  '${ValidationTypes.maxDescriptionLength} characters for description',  // Adjacent strings in list
  'Another message',
];

// ‚úÖ CORRECT: Extract long strings to variables
final descriptionRule = 'üìè Rules: ${ValidationTypes.minDescriptionLength}-'
    '${ValidationTypes.maxDescriptionLength} characters for description';

final messages = [
  'Some message',
  descriptionRule,  // Clean reference
  'Another message',
];

// ‚úÖ ALTERNATIVE: Use single interpolated string if under 80 chars
final messages = [
  'Some message',
  'üìè Rules: ${ValidationTypes.minDescriptionLength}-${ValidationTypes.maxDescriptionLength} chars',
  'Another message',
];
```

**Why This Rule Exists:**

- Adjacent strings in lists can be confusing to read
- Makes it unclear whether strings should be separate list items or concatenated
- Improves code clarity and maintainability
- Prevents accidental concatenation when separate items were intended

**Quick Fix Strategy:**

1. **Extract to variable** - Create a descriptively named variable above the list
2. **Use the variable** - Reference the variable in the list instead of inline strings
3. **Proper formatting** - Use proper string concatenation outside the list context

**Real-World Example from Error Formatter:**

```dart
// ‚ùå BEFORE: Adjacent strings causing linter error
static void showConventionalCommitHelp() {
  final messages = [
    '‚úÖ Correct format: type(scope): description',
    '',
    'üìè Rules:',
    '   ‚Ä¢ ${ValidationTypes.minDescriptionLength}-'
        '${ValidationTypes.maxDescriptionLength} characters for description',  // ‚ùå Adjacent strings
    '   ‚Ä¢ Lowercase description',
  ];
}

// ‚úÖ AFTER: Extracted to descriptive variable
static void showConventionalCommitHelp() {
  final descriptionRule = '   ‚Ä¢ ${ValidationTypes.minDescriptionLength}-'
      '${ValidationTypes.maxDescriptionLength} characters for description';

  final messages = [
    '‚úÖ Correct format: type(scope): description',
    '',
    'üìè Rules:',
    descriptionRule,  // ‚úÖ Clean and readable
    '   ‚Ä¢ Lowercase description',
  ];
}
```

**Benefits of This Approach:**

- ‚úÖ **Lint compliant** - No more no_adjacent_strings_in_list errors
- ‚úÖ **More readable** - Clear variable names explain the string's purpose
- ‚úÖ **Reusable** - Variables can be reused in multiple places
- ‚úÖ **Maintainable** - Changes only need to be made in one place
- ‚úÖ **Testable** - Variables can be unit tested independently

**Remember:** This rule specifically applies to **list literals**. Adjacent strings are perfectly fine in regular variable assignments and other contexts.

## üö® Immutability - Prevent Equals/HashCode Override Errors

### avoid_equals_and_hash_code_on_mutable_classes - Use @immutable Annotation

**THE RULE:** When overriding `==` and `hashCode` methods, the class must be annotated with `@immutable` to ensure proper immutability guarantees.

```dart
// ‚ùå LINT ERROR: avoid_equals_and_hash_code_on_mutable_classes
class User {
  final String name;
  final int age;

  const User(this.name, this.age);

  @override
  bool operator ==(Object other) => other is User && other.name == name && other.age == age;

  @override
  int get hashCode => Object.hash(name, age);
}

// ‚úÖ CORRECT: Add @immutable annotation
import 'package:meta/meta.dart';

@immutable
class User {
  final String name;
  final int age;

  const User(this.name, this.age);

  @override
  bool operator ==(Object other) => other is User && other.name == name && other.age == age;

  @override
  int get hashCode => Object.hash(name, age);
}
```

**Why This Rule Exists:**

- Ensures proper immutability contracts in Dart
- Prevents bugs from mutable state comparisons
- Required by Dart's type system for value objects
- Enables compiler optimizations for immutable objects

**When to Use @immutable:**

- ‚úÖ **Value Objects** - Data classes that represent values (Point, Color, ValidationResult)
- ‚úÖ **Configuration Classes** - Immutable settings and preferences
- ‚úÖ **DTOs** - Data transfer objects that shouldn't change
- ‚úÖ **Constants** - Classes that represent constant values

**When NOT to Use @immutable:**

- ‚ùå **Business Logic Classes** - Classes with mutable state and behavior
- ‚ùå **UI State Classes** - State management classes that need to change
- ‚ùå **Service Classes** - Classes that manage external resources
- ‚ùå **Controllers/Presenters** - Classes that coordinate actions

**Real-World Example from ValidationResult:**

```dart
// ‚ùå BEFORE: Mutable class with equals/hashCode override
class ValidationResult {
  final bool isValid;
  final String message;
  final Map<String, dynamic> details;

  @override
  bool operator ==(Object other) => other is ValidationResult && other.isValid == isValid && other.message == message;

  @override
  int get hashCode => Object.hash(isValid, message);
}

// ‚úÖ AFTER: Immutable class with proper annotation
import 'package:meta/meta.dart';

@immutable
class ValidationResult {
  final bool isValid;
  final String message;
  final Map<String, dynamic> details;

  @override
  bool operator ==(Object other) => other is ValidationResult && other.isValid == isValid && other.message == message;

  @override
  int get hashCode => Object.hash(isValid, message);
}
```

**Quick Fix Strategy:**

1. **Add import** - `import 'package:meta/meta.dart';`
2. **Add annotation** - `@immutable` before class declaration
3. **Use const literals** - Use `const {}` instead of `{}` in @immutable classes
4. **Verify immutability** - Ensure all fields are final and truly immutable

**Benefits of @immutable:**

- ‚úÖ **Type Safety** - Compiler guarantees immutability
- ‚úÖ **Performance** - Enables compiler optimizations
- ‚úÖ **Thread Safety** - Immutable objects are inherently thread-safe
- ‚úÖ **Predictability** - No unexpected state changes
- ‚úÖ **Testability** - Easier to test with known state

**Common Pitfalls:**

```dart
// ‚ùå PITFALL: Mutable collections in immutable class
@immutable
class Config {
  final List<String> items;  // ‚ùå List is mutable
  final Map<String, String> settings;  // ‚ùå Map is mutable

  Config(this.items, this.settings);  // Items can be modified externally!
}

// ‚úÖ SOLUTION: Use immutable collections or defensive copying
@immutable
class Config {
  final List<String> items;
  final Map<String, String> settings;

  Config(List<String> items, Map<String, String> settings)
      : items = List.unmodifiable(items),        // ‚úÖ Immutable copy
        settings = Map.unmodifiable(settings);   // ‚úÖ Immutable copy
}

// ‚úÖ BONUS: Use const literals in @immutable classes
@immutable
class ValidationResult {
  final bool isValid;
  final String message;
  final Map<String, dynamic> details;

  ValidationResult.success(String message, {Map<String, dynamic>? details})
      : this._(true, message, details ?? const {});  // ‚úÖ const literal

  const ValidationResult._(this.isValid, this.message, this.details);
}
```

**Remember:** `@immutable` is a contract. Breaking it with mutable state will lead to bugs and violates the type system's guarantees.

## üö® Const Literals - Prevent Immutability Contract Violations

### prefer_const_literals_to_create_immutables - Use const Literals in @immutable Classes

**THE RULE:** When passing literal collections (lists, maps, sets) to constructors of `@immutable` classes, use `const` literals instead of regular literals to maintain immutability guarantees.

```dart
// ‚ùå LINT ERROR: prefer_const_literals_to_create_immutables
@immutable
class ValidationResult {
  final Map<String, dynamic> details;
  final List<String> errors;

  ValidationResult.failure(String message)
      : this._(false, message, {}, []);  // ‚ùå Regular literals
}

// ‚úÖ CORRECT: Use const literals
@immutable
class ValidationResult {
  final Map<String, dynamic> details;
  final List<String> errors;

  ValidationResult.failure(String message)
      : this._(false, message, const {}, const []);  // ‚úÖ const literals
}
```

**Why This Rule Exists:**

- Ensures proper immutability contracts in `@immutable` classes
- Prevents accidental mutation of literal collections
- Required by Dart's type system for proper immutability
- Enables compiler optimizations for truly immutable objects

**When to Use const Literals:**

- ‚úÖ **All literal collections** in `@immutable` classes
- ‚úÖ **Empty collections** (`{}`, `[]`, `{}`) in `@immutable` constructors
- ‚úÖ **Static collections** that never change
- ‚úÖ **Default values** in `@immutable` class constructors

**When NOT to Use const (but still need care):**

- ‚ùå **Dynamic collections** that need to be modified before assignment
- ‚ùå **Collections from parameters** (use defensive copying instead)

**Real-World Example from Validator Interface:**

```dart
// ‚ùå BEFORE: Regular literals in @immutable context
abstract class TextValidator implements IValidator<String> {
  @override
  ValidationResult validate(String input) {
    if (input.isEmpty) {
      return ValidationResult.failure(
        'Input cannot be empty',
        errors: [  // ‚ùå Should be const
          ValidationError(...),
        ],
      );
    }
  }
}

// ‚úÖ AFTER: Const literals for immutability
abstract class TextValidator implements IValidator<String> {
  @override
  ValidationResult validate(String input) {
    if (input.isEmpty) {
      return ValidationResult.failure(
        'Input cannot be empty',
        errors: const [  // ‚úÖ const literal
          ValidationError(...),
        ],
      );
    }
  }
}
```

**Quick Fix Strategy:**

1. **Add const keyword** - Prefix literal collections with `const`
2. **Check all literals** - Review all `{}` and `[]` in `@immutable` classes
3. **Verify immutability** - Ensure the const literal matches the intent
4. **Use defensive copying** - For dynamic collections, use `List.unmodifiable()`

**Common Patterns:**

```dart
// ‚úÖ Pattern 1: Empty collections
@immutable
class Result {
  final List<String> items;
  final Map<String, int> counts;

  Result.empty()
      : items = const [],        // ‚úÖ const empty list
        counts = const {};       // ‚úÖ const empty map
}

// ‚úÖ Pattern 2: Static collections
@immutable
class Config {
  final List<String> supportedTypes;
  final Map<String, String> defaults;

  Config()
      : supportedTypes = const ['json', 'xml'],  // ‚úÖ const static list
        defaults = const {'format': 'json'};     // ‚úÖ const static map
}

// ‚úÖ Pattern 3: Defensive copying for dynamic data
@immutable
class UserData {
  final List<String> permissions;
  final Map<String, dynamic> metadata;

  UserData(List<String> perms, Map<String, dynamic> meta)
      : permissions = List.unmodifiable(perms),  // ‚úÖ Immutable copy
        metadata = Map.unmodifiable(meta);       // ‚úÖ Immutable copy
}
```

**Benefits of const Literals:**

- ‚úÖ **Type Safety** - Compiler guarantees true immutability
- ‚úÖ **Performance** - Compiler can optimize const literals
- ‚úÖ **Memory Efficiency** - Const literals are shared across instances
- ‚úÖ **Thread Safety** - Const objects are inherently thread-safe
- ‚úÖ **Predictability** - No unexpected mutations possible

**About one_member_abstracts Warning:**

```dart
// This warning can be safely ignored for interfaces used in DI
// ignore: one_member_abstracts
abstract class IValidator<T> {
  ValidationResult validate(T input);
}

// Reason: Interfaces with single methods are common in dependency injection
// and provide better testability and maintainability than function types
```

**Remember:** `const` literals are the foundation of true immutability in Dart. Always use them when creating literal collections in `@immutable` classes to maintain the immutability contract.
