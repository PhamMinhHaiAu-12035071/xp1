# Story 1.1: Core Authentication Infrastructure Setup

## Status
Draft

## Story

**As a** application developer,
**I want** to establish the core authentication infrastructure with domain entities, JWT service, secure storage, and HTTP client setup,
**so that** I can build real authentication functionality on a solid foundation while maintaining Clean Architecture principles.

## Acceptance Criteria

1. Domain entities (UserEntity, TokenEntity, AuthFailure) are created following existing patterns
2. JWT service is implemented with token parsing and validation capabilities  
3. Secure storage service is implemented using FlutterSecureStorage for token persistence
4. Chopper HTTP client is configured with environment integration for API communication
5. Required dependencies are added and code generation is set up properly
6. All new code follows existing project patterns (Injectable DI, Freezed models, Repository pattern)

## Tasks / Subtasks

### Setup and Dependencies (AC: 5, 6)
- [ ] Add required dependencies to pubspec.yaml
  - [ ] Add chopper for HTTP client
  - [ ] Add flutter_secure_storage for JWT token storage
  - [ ] Add chopper_generator for development dependencies
- [ ] Run code generation setup commands
  - [ ] Execute `flutter pub get` to install dependencies
  - [ ] Execute `dart run build_runner build --delete-conflicting-outputs` to generate initial code

### Domain Layer Implementation (AC: 1, 6)
- [ ] Create authentication domain entities using Freezed
  - [ ] Implement `lib/features/authentication/domain/entities/user_entity.dart` with UserEntity (id, username, email)
  - [ ] Implement `lib/features/authentication/domain/entities/token_entity.dart` with TokenEntity (accessToken, refreshToken, expiresIn, issuedAt) and expiration helpers
  - [ ] Implement `lib/features/authentication/domain/failures/auth_failure.dart` with sealed class AuthFailure variants
- [ ] Create domain repository interface
  - [ ] Implement `lib/features/authentication/domain/repositories/auth_repository.dart` abstract class
- [ ] Create domain use cases
  - [ ] Implement `lib/features/authentication/domain/usecases/login_usecase.dart` with LoginInput/LoginResult models

### Core Services Implementation (AC: 2, 3, 6) 
- [ ] Create secure storage service
  - [ ] Implement `lib/core/storage/secure_storage_service.dart` using FlutterSecureStorage
  - [ ] Add methods for storing/retrieving access tokens and refresh tokens
  - [ ] Add method for clearing all tokens (logout)
  - [ ] Register service with Injectable dependency injection
- [ ] Create JWT service for token management
  - [ ] Implement `lib/core/security/jwt_service.dart` with JWT parsing using dart:convert
  - [ ] Add token expiration checking functionality
  - [ ] Add user info extraction from JWT payload
  - [ ] Register service with Injectable dependency injection

### HTTP Client Setup (AC: 4, 6)
- [ ] Configure Chopper HTTP client with environment integration
  - [ ] Create `lib/core/network/api_client.dart` that integrates with existing EnvConfigRepository
  - [ ] Set up base URL from environment configuration (apiUrl)
  - [ ] Configure JSON converter for request/response handling
  - [ ] Register ApiClient with Injectable dependency injection
- [ ] Set up interceptors foundation
  - [ ] Create placeholder interceptor structure for future authentication header injection
  - [ ] Ensure debug logging is enabled when isDebugMode is true

### Testing Infrastructure (AC: 6)
- [ ] Create unit tests for domain entities
  - [ ] Test UserEntity creation and equality
  - [ ] Test TokenEntity expiration logic and helpers
  - [ ] Test AuthFailure sealed class variants
- [ ] Create unit tests for core services
  - [ ] Test SecureStorageService token storage and retrieval
  - [ ] Test JwtService token parsing and validation
  - [ ] Mock FlutterSecureStorage for testing

## Dev Notes

### Previous Story Insights
This is the first story in the epic. No previous story insights available.

### Technical Architecture Context

**Existing Project Patterns** [Source: Codebase Analysis]:
- **Clean Architecture**: Features organized in `lib/features/{feature}/` with domain, infrastructure, presentation layers
- **Dependency Injection**: Uses GetIt + Injectable pattern with `@injectable` and `@LazySingleton` annotations
- **Repository Pattern**: Abstract repositories in domain layer, implementations in infrastructure layer
- **Environment Configuration**: Uses EnvConfigRepository for environment-specific values (API URLs, timeouts)
- **Code Generation**: Uses Freezed for immutable data classes, json_serializable for serialization
- **Error Handling**: Uses fpdart Either<Failure, Success> pattern for functional error handling

**Data Models** [Source: planning.md and existing patterns]:
- **UserEntity**: Domain entity with id, username, email (Freezed-generated immutable)
- **TokenEntity**: Domain entity with accessToken, refreshToken, expiresIn, issuedAt plus calculated expiration helpers
- **AuthFailure**: Sealed class with variants: invalidCredentials, networkError, serverError, tokenExpired, unauthorized, unknown

**Environment Integration** [Source: lib/features/env/domain/env_config_repository.dart]:
- **API URL**: Access via `EnvConfigRepository.apiUrl` (already configured with "https://dev-api.xp1.com/api")
- **Debug Mode**: Access via `EnvConfigRepository.isDebugMode` for conditional logging
- **Timeout**: Access via `EnvConfigRepository.apiTimeoutMs` (30000ms default)

**File Locations** [Source: Project Structure Analysis]:
- **Domain Entities**: `lib/features/authentication/domain/entities/`
- **Domain Failures**: `lib/features/authentication/domain/failures/`
- **Domain Repositories**: `lib/features/authentication/domain/repositories/`
- **Domain Use Cases**: `lib/features/authentication/domain/usecases/`
- **Core Services**: `lib/core/storage/`, `lib/core/security/`, `lib/core/network/`
- **Tests**: `test/features/authentication/domain/` for domain tests, `test/core/` for core service tests

**Dependency Injection Setup** [Source: lib/core/di/injection_container.dart]:
- Use `@injectable` for regular services
- Use `@LazySingleton()` for services that should be singletons
- Services are registered in generated `injection_container.config.dart` via build_runner

**Integration Points** [Source: Existing Codebase]:
- **Environment Config**: Inject `EnvConfigRepository` to access API URLs and configuration
- **Existing Login Form**: Located at `lib/features/authentication/presentation/widgets/login_form.dart` (contains fake 2-second delay on line 285)
- **Dependency Container**: Services registered automatically via Injectable, access via `GetIt.instance<ServiceType>()`

**Security Requirements** [Source: planning.md]:
- JWT tokens must be stored in FlutterSecureStorage only (never plain text)
- Token validation must check structure and expiration
- No JWT tokens should ever be logged (even in debug mode)

### Testing Standards

**Test File Locations** [Source: Project Structure]:
- Domain tests: `test/features/authentication/domain/entities/`, `test/features/authentication/domain/usecases/`
- Core service tests: `test/core/storage/`, `test/core/security/`, `test/core/network/`

**Testing Frameworks** [Source: pubspec.yaml]:
- **Unit Tests**: Use `test` package and `flutter_test`
- **Mocking**: Use `mocktail` for mock implementations
- **BLoC Testing**: Use `bloc_test` package (for future BLoC integration)

**Testing Patterns**:
- Mock external dependencies (FlutterSecureStorage, EnvConfigRepository) 
- Test both success and failure scenarios for JWT service
- Verify proper error handling and Either<Failure, Success> returns
- Test TokenEntity expiration logic with various datetime scenarios

**Critical Testing Requirements**:
- SecureStorageService must be fully tested with mocked FlutterSecureStorage
- JwtService token parsing must handle malformed tokens gracefully
- Domain entities must test Freezed-generated equality and serialization

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-20 | 1.0 | Initial story creation with comprehensive technical context | Story Manager |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review of the completed story implementation*