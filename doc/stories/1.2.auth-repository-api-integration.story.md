# Story 1.2: Authentication Repository and API Integration

## Status
Draft

## Story

**As a** application developer,
**I want** to implement the authentication repository with real API integration, mappers, and data models,
**so that** I can provide concrete authentication functionality that handles login, logout, and token refresh operations through secure API calls.

## Acceptance Criteria

1. Authentication API service is created using Chopper with proper endpoint definitions
2. Infrastructure models (LoginRequest, LoginResponse, UserModel) are implemented with JSON serialization
3. Mappers are created to convert between API models and domain entities following base mapper pattern
4. AuthRepository implementation is created with real login/logout/refresh functionality using Either pattern
5. API service integrates with secure storage for token persistence and retrieval
6. HTTP error handling is implemented with proper AuthFailure mapping
7. All implementation follows existing project patterns and integrates with Story 1.1 infrastructure

## Tasks / Subtasks

### Infrastructure Models Implementation (AC: 2, 7)
- [ ] Create API request/response models with JSON serialization
  - [ ] Implement `lib/features/authentication/infrastructure/models/login_request.dart` with Freezed
    - [ ] Fields: username, password, deviceId (optional), rememberMe (default false)
    - [ ] Add JSON serialization with json_annotation
  - [ ] Implement `lib/features/authentication/infrastructure/models/login_response.dart` with Freezed
    - [ ] Fields: accessToken, refreshToken, expiresIn, user (UserModel), isFirstLogin (default false)
    - [ ] Add JSON serialization with json_annotation
  - [ ] Implement `lib/features/authentication/infrastructure/models/user_model.dart` with Freezed
    - [ ] Fields: id, username, email, fullName (optional), avatarUrl (optional)
    - [ ] Add JSON serialization with json_annotation
- [ ] Run code generation for models
  - [ ] Execute `dart run build_runner build --delete-conflicting-outputs` to generate JSON serialization

### Base Mapper and Authentication Mappers (AC: 3, 7)
- [ ] Create base mapper abstraction following existing patterns
  - [ ] Implement `lib/core/mappers/base_mapper.dart` with generic type-safe contract
    - [ ] Abstract method: fromModelToEntity(TModel model) -> TEntity
    - [ ] Abstract method: fromEntityToModel(TEntity entity) -> TModel (with default UnimplementedError)
    - [ ] Helper methods for list conversions
  - [ ] Register with Injectable if needed for DI pattern consistency
- [ ] Create authentication-specific mappers
  - [ ] Implement `lib/features/authentication/infrastructure/mappers/user_mapper.dart`
    - [ ] Extend BaseMapper<UserModel, UserEntity>
    - [ ] Implement bidirectional conversion between UserModel and UserEntity
    - [ ] Register with @injectable annotation
  - [ ] Implement `lib/features/authentication/infrastructure/mappers/auth_mapper.dart`
    - [ ] Handles LoginResponse to LoginResult conversion (depends on UserMapper)
    - [ ] Handles LoginInput to LoginRequest conversion
    - [ ] Creates TokenEntity from LoginResponse token fields
    - [ ] Register with @injectable annotation and inject UserMapper dependency
  - [ ] Implement `lib/features/authentication/infrastructure/mappers/token_mapper.dart`
    - [ ] Extend BaseMapper<LoginResponse, TokenEntity> for token-specific conversions
    - [ ] Handle token expiration calculations with DateTime.now() for issuedAt
    - [ ] Register with @injectable annotation

### Authentication API Service Implementation (AC: 1, 7)
- [ ] Create Chopper API service for authentication endpoints
  - [ ] Implement `lib/features/authentication/infrastructure/services/auth_api_service.dart`
    - [ ] Use @ChopperApi annotation with baseUrl: '/auth'
    - [ ] POST /login endpoint accepting Map<String, dynamic> body
    - [ ] POST /refresh endpoint for token refresh functionality
    - [ ] Response type: Response<Map<String, dynamic>> for JSON handling
    - [ ] Generate service implementation with chopper_generator
  - [ ] Register API service with dependency injection
    - [ ] Add to appropriate DI module or ensure automatic registration via @injectable

### Repository Implementation with Error Handling (AC: 4, 5, 6, 7)
- [ ] Implement AuthRepository with real functionality
  - [ ] Create `lib/features/authentication/infrastructure/repositories/auth_repository_impl.dart`
    - [ ] Extend abstract AuthRepository from domain layer
    - [ ] Use @LazySingleton(as: AuthRepository) for DI registration
    - [ ] Inject dependencies: AuthApiService, SecureStorageService, AuthMapper
  - [ ] Implement login method with comprehensive error handling
    - [ ] Convert LoginInput to LoginRequest via AuthMapper
    - [ ] Call AuthApiService.login with request data
    - [ ] Handle HTTP status codes: 401 (invalid credentials), 422 (validation), 500+ (server errors)
    - [ ] Parse successful response via LoginResponse.fromJson
    - [ ] Convert to LoginResult via AuthMapper
    - [ ] Store tokens in SecureStorageService if rememberMe is true
    - [ ] Return Either<AuthFailure, LoginResult>
  - [ ] Implement token refresh method
    - [ ] Retrieve refresh token from SecureStorageService
    - [ ] Call AuthApiService.refreshToken
    - [ ] Handle 401 response by clearing stored tokens
    - [ ] Update stored tokens on successful refresh
    - [ ] Return Either<AuthFailure, TokenEntity>
  - [ ] Implement logout method
    - [ ] Clear all tokens from SecureStorageService
    - [ ] Return Either<AuthFailure, void>
- [ ] Add comprehensive error handling
  - [ ] Map SocketException to AuthFailure.networkError
  - [ ] Map FormatException to AuthFailure.unknown
  - [ ] Map HTTP status codes to appropriate AuthFailure variants
  - [ ] Ensure no exceptions bubble up, all wrapped in Either pattern

### Integration with Story 1.1 Infrastructure (AC: 5, 7)
- [ ] Verify integration with existing core services
  - [ ] Ensure SecureStorageService from Story 1.1 is properly injected
  - [ ] Verify JWT token storage keys match between repository and storage service
  - [ ] Confirm TokenEntity from Story 1.1 is used consistently
- [ ] Test dependency injection configuration
  - [ ] Verify all new services register correctly with GetIt
  - [ ] Run `dart run build_runner build` to update injection container
  - [ ] Ensure no circular dependency issues

### Testing Infrastructure (AC: 7)
- [ ] Create unit tests for mappers
  - [ ] Test `test/features/authentication/infrastructure/mappers/user_mapper_test.dart`
    - [ ] Test bidirectional conversion UserModel ↔ UserEntity
    - [ ] Test field mapping accuracy
    - [ ] Test null handling for optional fields
  - [ ] Test `test/features/authentication/infrastructure/mappers/auth_mapper_test.dart`
    - [ ] Test LoginResponse to LoginResult conversion
    - [ ] Test LoginInput to LoginRequest conversion
    - [ ] Test TokenEntity creation with proper expiration calculation
  - [ ] Test `test/core/mappers/base_mapper_test.dart`
    - [ ] Test list conversion helper methods
    - [ ] Test UnimplementedError for reverse conversion
- [ ] Create unit tests for repository implementation
  - [ ] Test `test/features/authentication/infrastructure/repositories/auth_repository_impl_test.dart`
    - [ ] Mock AuthApiService, SecureStorageService, AuthMapper dependencies
    - [ ] Test successful login flow with token storage
    - [ ] Test login error scenarios (401, 422, 500, network failures)
    - [ ] Test token refresh success and failure scenarios
    - [ ] Test logout functionality
    - [ ] Verify Either<Failure, Success> patterns
- [ ] Create unit tests for API service
  - [ ] Test `test/features/authentication/infrastructure/services/auth_api_service_test.dart`
    - [ ] Mock Chopper HTTP client responses
    - [ ] Test request serialization and response deserialization
    - [ ] Test endpoint path and method configurations

## Dev Notes

### Previous Story Insights
**From Story 1.1** [Assumed Complete]:
- Domain entities (UserEntity, TokenEntity, AuthFailure) are available
- JWT service with token parsing and validation is implemented
- SecureStorageService with FlutterSecureStorage is available
- Basic Chopper HTTP client configuration is set up
- Dependencies (chopper, flutter_secure_storage, injectable) are added
- Code generation infrastructure is configured

### Technical Architecture Context

**API Integration Patterns** [Source: planning.md]:
- **Chopper Service Pattern**: Use @ChopperApi with baseUrl and endpoint decorators
- **Request/Response Models**: Freezed classes with JSON serialization for API communication
- **Error Handling**: HTTP status code mapping to domain failures
- **Token Management**: Store JWT tokens after successful authentication, clear on logout

**Data Flow Architecture** [Source: planning.md]:
```
API JSON → Model (fromJson) → Mapper → Entity → Use Case
Entity → Mapper → Model (toJson) → API JSON
```

**Mapper Pattern Implementation** [Source: planning.md]:
- **BaseMapper Contract**: Abstract class with generic type safety
- **Type Safety**: BaseMapper<TModel, TEntity> ensures compile-time checking
- **Dependency Injection**: Mappers are @injectable and can depend on other mappers
- **Bidirectional**: Support both Model→Entity and Entity→Model conversions when needed

**Repository Implementation Pattern** [Source: Existing Codebase Analysis]:
- **Interface Segregation**: Abstract repository in domain, concrete implementation in infrastructure
- **Either Pattern**: All repository methods return Either<Failure, Success>
- **Dependency Injection**: Use @LazySingleton(as: InterfaceType) for repository registration
- **Error Boundary**: Repository catches all exceptions and converts to domain failures

**File Locations** [Source: Project Structure Analysis]:
- **Infrastructure Models**: `lib/features/authentication/infrastructure/models/`
- **Infrastructure Mappers**: `lib/features/authentication/infrastructure/mappers/`
- **Infrastructure Services**: `lib/features/authentication/infrastructure/services/`
- **Infrastructure Repositories**: `lib/features/authentication/infrastructure/repositories/`
- **Core Mappers**: `lib/core/mappers/`
- **Tests**: Mirror source structure in `test/` directory

**API Endpoints** [Source: planning.md]:
- **Base URL**: Uses EnvConfigRepository.apiUrl (https://dev-api.xp1.com/api)
- **Login Endpoint**: POST /auth/login (username, password, deviceId?, rememberMe)
- **Refresh Endpoint**: POST /auth/refresh (refresh_token)
- **Response Format**: JSON with accessToken, refreshToken, expiresIn, user object

**Security Integration** [Source: planning.md + Story 1.1]:
- **Secure Storage**: Use SecureStorageService for JWT token persistence
- **Token Storage Keys**: Match keys used by SecureStorageService (access_token, refresh_token)
- **No Plain Text**: JWT tokens never stored in plain text or logged
- **Auto Refresh**: Repository should support token refresh flow

**Environment Integration** [Source: lib/features/env/domain/env_config_repository.dart]:
- **API Configuration**: HTTP client should use EnvConfigRepository for base URL and timeout
- **Debug Logging**: Enable request/response logging when isDebugMode is true
- **Timeout Handling**: Use apiTimeoutMs for request timeout configuration

### Testing Standards

**Test File Locations**:
- Infrastructure tests: `test/features/authentication/infrastructure/`
- Core mapper tests: `test/core/mappers/`

**Testing Frameworks** [Source: pubspec.yaml]:
- **Unit Tests**: Use `test` package and `flutter_test`
- **Mocking**: Use `mocktail` for mock implementations
- **BLoC Testing**: Use `bloc_test` package for future BLoC integration

**Testing Patterns for Repository Layer**:
- Mock all external dependencies (API service, storage service, mappers)
- Test both success and failure scenarios for all methods
- Verify proper error mapping from HTTP status codes to AuthFailure
- Test token storage behavior (store on successful login, clear on logout)
- Validate Either<Failure, Success> return patterns

**Critical Testing Requirements**:
- AuthRepository must handle all HTTP status codes gracefully
- Token refresh flow must handle expired refresh tokens by clearing storage
- Mappers must preserve data integrity in bidirectional conversions
- JSON serialization must handle optional fields correctly
- No exceptions should escape repository layer (all converted to Either.Left failures)

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-20 | 1.0 | Initial story creation based on Epic requirements and Story 1.1 context | Story Manager |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results
*Results from QA Agent review of the completed story implementation*