---
globs: *.dart
description: Dart coding style guidelines to prevent linter errors and warnings
---

# Dart Coding Style Guidelines

## üöÄ DART 3+ MODERN SYNTAX - HIGHEST PRIORITY

> **MANDATORY**: Always prioritize Dart 3+ features and syntax over legacy patterns. Use the latest language constructs for better type safety, expressiveness, and performance.

### 1. Pattern Matching & Switch Expressions (Dart 3.0+) - ESSENTIAL

**THE GOLDEN RULE:** Use pattern matching and switch expressions for type-safe, exhaustive handling of data.

#### **1.1. Switch Expressions - PREFER Over Switch Statements**

```dart
// ‚ùå OLD STYLE: Switch statement
String getMessage(Status status) {
  switch (status) {
    case Status.loading:
      return 'Loading...';
    case Status.success:
      return 'Success!';
    case Status.error:
      return 'Error occurred';
    default:
      return 'Unknown';
  }
}

// ‚úÖ DART 3+: Switch expression (more concise, exhaustive)
String getMessage(Status status) => switch (status) {
  Status.loading => 'Loading...',
  Status.success => 'Success!',
  Status.error => 'Error occurred',
};
```

#### **1.2. Pattern Matching with if-case - MODERN VALIDATION**

```dart
// ‚ùå OLD STYLE: Manual type checking and casting
void processUser(Object data) {
  if (data is Map<String, dynamic>) {
    final map = data as Map<String, dynamic>;
    if (map.containsKey('name') && map.containsKey('age')) {
      final name = map['name'];
      final age = map['age'];
      if (name is String && age is int) {
        print('User: $name, Age: $age');
      }
    }
  }
}

// ‚úÖ DART 3+: Pattern matching with if-case
void processUser(Object data) {
  if (data case {'name': String name, 'age': int age}) {
    print('User: $name, Age: $age');
  }
}
```

#### **1.3. Destructuring Patterns - MANDATORY for Complex Data**

```dart
// ‚ùå OLD STYLE: Manual destructuring
final coordinates = [10.0, 20.0, 30.0];
final x = coordinates[0];
final y = coordinates[1];
final z = coordinates[2];

// ‚úÖ DART 3+: Destructuring assignment
final coordinates = [10.0, 20.0, 30.0];
final [x, y, z] = coordinates;

// ‚úÖ DART 3+: Advanced destructuring with rest elements
final numbers = [1, 2, 3, 4, 5];
final [first, second, ...rest] = numbers;
```

### 2. Records & Tuple Types (Dart 3.0+) - ESSENTIAL

**THE GOLDEN RULE:** Use records for multiple return values and lightweight data structures instead of creating classes.

#### **2.1. Multiple Return Values - PREFER Records**

```dart
// ‚ùå OLD STYLE: Creating class for simple data
class UserResult {
  const UserResult(this.user, this.error);
  final User? user;
  final String? error;
}

Future<UserResult> getUser(String id) async {
  // implementation
  return UserResult(user, null);
}

// ‚úÖ DART 3+: Records for multiple returns
Future<(User?, String?)> getUser(String id) async {
  // implementation
  return (user, null);
}

// ‚úÖ DART 3+: Named records for clarity
Future<({User? user, String? error})> getUser(String id) async {
  // implementation
  return (user: user, error: null);
}
```

#### **2.2. Record Destructuring - MANDATORY Pattern**

```dart
// ‚úÖ DART 3+: Record destructuring in method calls
final result = await getUser('123');
final (user, error) = result;

// ‚úÖ DART 3+: Direct destructuring in variable declaration
final (user, error) = await getUser('123');

// ‚úÖ DART 3+: Named record destructuring
final result = await getUserDetailed('123');
final (user: userData, error: errorMessage, timestamp: time) = result;
```

#### **2.3. Records in Collections - MODERN DATA STRUCTURES**

```dart
// ‚úÖ DART 3+: Records in lists for coordinate data
final points = [
  (10.0, 20.0),
  (30.0, 40.0),
  (50.0, 60.0),
];

for (final (x, y) in points) {
  print('Point: ($x, $y)');
}

// ‚úÖ DART 3+: Named records for complex data
final users = [
  (name: 'Alice', age: 30, email: 'alice@example.com'),
  (name: 'Bob', age: 25, email: 'bob@example.com'),
];

for (final (name: userName, age: userAge, :email) in users) {
  print('$userName ($userAge): $email');
}
```

### 3. Sealed Classes & Class Modifiers (Dart 3.0+) - CRITICAL

**THE GOLDEN RULE:** Use sealed classes for algebraic data types and enforce exhaustive pattern matching.

#### **3.1. Sealed Classes - MANDATORY for State/Result Types**

```dart
// ‚úÖ DART 3+: Sealed class for API states (exhaustive matching)
sealed class ApiState {}

final class LoadingState extends ApiState {}

final class SuccessState extends ApiState {
  const SuccessState(this.data);
  final String data;
}

final class ErrorState extends ApiState {
  const ErrorState(this.message);
  final String message;
}

// ‚úÖ DART 3+: Exhaustive pattern matching (compiler enforced)
String handleState(ApiState state) => switch (state) {
  LoadingState() => 'Loading...',
  SuccessState(:final data) => 'Success: $data',
  ErrorState(:final message) => 'Error: $message',
  // No default needed - compiler ensures exhaustiveness!
};
```

#### **3.2. Class Modifiers - ENFORCE Design Intent**

```dart
// ‚úÖ DART 3+: Base class (can be extended but not implemented)
base class Vehicle {
  void startEngine() => print('Engine started');
}

// ‚úÖ DART 3+: Interface class (can be implemented but not extended)
interface class Drawable {
  void draw();
}

// ‚úÖ DART 3+: Final class (cannot be extended or implemented)
final class DatabaseConnection {
  void connect() => print('Connected to database');
}

// ‚úÖ DART 3+: Mixin class (explicit mixin declaration)
mixin class Loggable {
  void log(String message) => print('Log: $message');
}
```

### 4. Extension Types (Dart 3.3+) - ZERO-COST WRAPPERS

**THE GOLDEN RULE:** Use extension types for zero-cost type safety without runtime overhead.

#### **4.1. Type-Safe Wrappers - PREFER Extension Types**

```dart
// ‚ùå OLD STYLE: Runtime overhead with wrapper classes
class UserId {
  const UserId(this.value);
  final String value;
}

// ‚úÖ DART 3.3+: Zero-cost extension type
extension type UserId(String value) {
  UserId.fromString(String str) : value = str;

  bool get isValid => value.isNotEmpty && value.length > 3;

  String get displayName => 'User($value)';
}

// Usage: No runtime cost, full type safety
void processUser(UserId id) {
  if (id.isValid) {
    print(id.displayName);
  }
}
```

#### **4.2. Extension Types for API Responses - MODERN PATTERN**

```dart
// ‚úÖ DART 3.3+: Extension types for API data
extension type ApiResponse(Map<String, dynamic> json) {
  ApiResponse.fromJson(Map<String, dynamic> data) : json = data;

  String get status => json['status'] as String;
  T? getData<T>(String key) => json['data']?[key] as T?;
  bool get isSuccess => status == 'success';
}

// Usage: Type-safe API handling
void handleResponse(ApiResponse response) {
  if (response.isSuccess) {
    final name = response.getData<String>('name');
    print('Success: $name');
  }
}
```

### 5. Null-Aware Elements (Dart 3.8+) - COLLECTION SAFETY

**THE GOLDEN RULE:** Use null-aware elements to conditionally insert collection elements safely.

#### **5.1. Conditional Collection Elements - MODERN SYNTAX**

```dart
// ‚ùå OLD STYLE: Manual null checking
List<String> buildItems(String? optionalItem) {
  final items = <String>['item1', 'item2'];
  if (optionalItem != null) {
    items.add(optionalItem);
  }
  return items;
}

// ‚úÖ DART 3.8+: Null-aware collection elements
List<String> buildItems(String? optionalItem) => [
  'item1',
  'item2',
  if (optionalItem != null) optionalItem,  // Traditional if
  ...?optionalItem != null ? [optionalItem] : null,  // Null-aware spread
];

// ‚úÖ DART 3.8+: Advanced null-aware elements
Widget buildColumn(List<Widget>? additionalWidgets) {
  return Column(
    children: [
      const Text('Header'),
      const Spacer(),
      ...?additionalWidgets,  // Only spreads if not null
      const Text('Footer'),
    ],
  );
}
```

#### **5.2. Map Null-Aware Elements - SAFE MAP BUILDING**

```dart
// ‚úÖ DART 3.8+: Null-aware map elements
Map<String, String> buildConfig(String? apiKey, String? secretKey) => {
  'app_name': 'MyApp',
  'version': '1.0.0',
  if (apiKey != null) 'api_key': apiKey,
  ...?secretKey != null ? {'secret_key': secretKey} : null,
};
```

### 6. Wildcard Variables (Dart 3.7+) - IGNORE UNUSED VALUES

**THE GOLDEN RULE:** Use wildcard variables `_` to explicitly ignore values in pattern matching.

#### **6.1. Pattern Matching with Wildcards - CLEAN SYNTAX**

```dart
// ‚úÖ DART 3.7+: Multiple wildcards (no collision)
void processRecord(Record record) {
  switch (record) {
    case (int value, _, String name):  // Ignore middle value
      print('Got int $value and string $name');
    case (_, double value, _):  // Only care about middle value
      print('Got double $value');
  }
}

// ‚úÖ DART 3.7+: Wildcards in destructuring
final coordinates = [10.0, 20.0, 30.0, 40.0];
final [x, _, z, _] = coordinates;  // Only use x and z
```

#### **6.2. Function Parameters Wildcards - CALLBACK SIGNATURES**

```dart
// ‚úÖ DART 3.7+: Wildcard parameters in callbacks
void setupListener() {
  stream.listen(
    (data) => processData(data),
    onError: (_) => print('Error occurred'),  // Don't need error details
    onDone: () => print('Stream completed'),
  );
}
```

### 7. Enhanced Enums (Dart 3.0+) - POWERFUL ENUM FEATURES

**THE GOLDEN RULE:** Use enhanced enums with methods, constructors, and mixins instead of static classes.

#### **7.1. Enums with Methods and Fields - MODERN APPROACH**

```dart
// ‚úÖ DART 3.0+: Enhanced enums with behavior
enum HttpStatus {
  ok(200, 'OK'),
  notFound(404, 'Not Found'),
  internalError(500, 'Internal Server Error');

  const HttpStatus(this.code, this.message);

  final int code;
  final String message;

  bool get isSuccess => code >= 200 && code < 300;
  bool get isError => code >= 400;

  static HttpStatus fromCode(int code) {
    return values.firstWhere(
      (status) => status.code == code,
      orElse: () => internalError,
    );
  }
}

// Usage: Rich enum behavior
void handleResponse(int statusCode) {
  final status = HttpStatus.fromCode(statusCode);
  if (status.isError) {
    print('Error: ${status.message}');
  }
}
```

#### **7.2. Enums with Mixins - EXTEND FUNCTIONALITY**

```dart
// ‚úÖ DART 3.0+: Enums with mixins
mixin JsonSerializable {
  Map<String, dynamic> toJson();
}

enum Priority with JsonSerializable {
  low(1, 'Low Priority'),
  medium(2, 'Medium Priority'),
  high(3, 'High Priority');

  const Priority(this.value, this.description);

  final int value;
  final String description;

  @override
  Map<String, dynamic> toJson() => {
    'priority': name,
    'value': value,
    'description': description,
  };
}
```

### 8. Advanced Pattern Matching Examples - REAL-WORLD USAGE

#### **8.1. JSON Validation & Processing - MODERN API HANDLING**

```dart
// ‚úÖ DART 3+: Comprehensive JSON pattern matching
void processApiResponse(Object? response) {
  switch (response) {
    case {
      'status': 'success',
      'data': {
        'user': {
          'name': String name,
          'age': int age,
          'email': String email,
        }
      }
    }:
      print('User: $name ($age) - $email');

    case {'status': 'error', 'message': String message}:
      throw ApiException(message);

    case {'status': 'loading'}:
      showLoadingIndicator();

    case null:
      throw ApiException('No response received');

    default:
      throw ApiException('Invalid response format');
  }
}
```

#### **8.2. State Machine Implementation - SEALED CLASSES + PATTERNS**

```dart
// ‚úÖ DART 3+: Type-safe state machine
sealed class ConnectionState {}

final class Disconnected extends ConnectionState {}

final class Connecting extends ConnectionState {
  const Connecting(this.attempt);
  final int attempt;
}

final class Connected extends ConnectionState {
  const Connected(this.sessionId);
  final String sessionId;
}

final class Failed extends ConnectionState {
  const Failed(this.error, this.retryable);
  final String error;
  final bool retryable;
}

// ‚úÖ DART 3+: Exhaustive state handling
String getStatusMessage(ConnectionState state) => switch (state) {
  Disconnected() => 'Not connected',
  Connecting(:final attempt) => 'Connecting... (attempt $attempt)',
  Connected(:final sessionId) => 'Connected (session: $sessionId)',
  Failed(:final error, retryable: true) => 'Failed: $error (retrying...)',
  Failed(:final error, retryable: false) => 'Failed permanently: $error',
};
```

### 9. Modern BLoC/Cubit Patterns with Dart 3+ - FLUTTER INTEGRATION

#### **9.1. Sealed State Classes - TYPE-SAFE STATE MANAGEMENT**

```dart
// ‚úÖ DART 3+: Sealed state with exhaustive matching
sealed class UserState {}

final class UserInitial extends UserState {}

final class UserLoading extends UserState {}

final class UserSuccess extends UserState {
  const UserSuccess(this.user);
  final User user;
}

final class UserError extends UserState {
  const UserError(this.message);
  final String message;
}

// ‚úÖ DART 3+: Pattern matching in BlocBuilder
class UserPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<UserCubit, UserState>(
      builder: (context, state) => switch (state) {
        UserInitial() => const Text('Press button to load user'),
        UserLoading() => const CircularProgressIndicator(),
        UserSuccess(:final user) => UserWidget(user),
        UserError(:final message) => ErrorWidget(message),
      },
    );
  }
}
```

### 10. Type Safety Best Practices - DART 3+ PATTERNS

#### **10.1. Result Type with Sealed Classes - ERROR HANDLING**

```dart
// ‚úÖ DART 3+: Type-safe result handling
sealed class Result<T, E> {}

final class Success<T, E> extends Result<T, E> {
  const Success(this.value);
  final T value;
}

final class Failure<T, E> extends Result<T, E> {
  const Failure(this.error);
  final E error;
}

// ‚úÖ DART 3+: Pattern matching for result handling
Future<Result<User, String>> fetchUser(String id) async {
  try {
    final user = await userService.getUser(id);
    return Success(user);
  } catch (e) {
    return Failure(e.toString());
  }
}

// Usage with exhaustive matching
void handleUserFetch(String userId) async {
  final result = await fetchUser(userId);

  switch (result) {
    case Success(:final value):
      displayUser(value);
    case Failure(:final error):
      showError(error);
  }
}
```

## üì¶ SMART PACKAGE USAGE - MAXIMIZE DEVELOPMENT VELOCITY

> **GOLDEN RULE**: Always leverage existing packages intelligently over manual implementation. Use the ecosystem to accelerate development and reduce bugs.

### 1. State Management with BLoC Ecosystem - COMPREHENSIVE SOLUTION

**THE PRINCIPLE:** Use the complete BLoC ecosystem for predictable, testable state management instead of manual state handling.

#### **1.1. BLoC + Flutter BLoC - MODERN STATE MANAGEMENT**

```dart
// ‚ùå MANUAL STATE: Custom notifier implementation
class CounterNotifier extends ChangeNotifier {
  int _count = 0;
  int get count => _count;

  void increment() {
    _count++;
    notifyListeners();
  }
}

// ‚úÖ BLOC PACKAGE: Type-safe, testable state management
@injectable
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0);

  void increment() => emit(state + 1);
}

// ‚úÖ FLUTTER_BLOC: Declarative UI updates
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CounterCubit, int>(
      builder: (context, count) => Text('$count'),
    );
  }
}
```

#### **1.2. HydratedBloc - AUTOMATIC PERSISTENCE**

```dart
// ‚ùå MANUAL PERSISTENCE: Custom SharedPreferences handling
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0) {
    _loadFromPrefs();
  }

  void _loadFromPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    final saved = prefs.getInt('counter') ?? 0;
    emit(saved);
  }

  void increment() {
    emit(state + 1);
    _saveToPrefs();
  }

  void _saveToPrefs() async {
    final prefs = await SharedPreferences.getInstance();
    await prefs.setInt('counter', state);
  }
}

// ‚úÖ HYDRATED_BLOC: Automatic state persistence
class CounterCubit extends HydratedCubit<int> {
  CounterCubit() : super(0);

  void increment() => emit(state + 1);

  @override
  int? fromJson(Map<String, dynamic> json) => json['value'] as int?;

  @override
  Map<String, dynamic>? toJson(int state) => {'value': state};
}
```

#### **1.3. BlocTest - COMPREHENSIVE TESTING**

```dart
// ‚ùå MANUAL TESTING: Complex async testing
test('should increment counter', () async {
  final cubit = CounterCubit();
  final states = <int>[];

  final subscription = cubit.stream.listen(states.add);

  cubit.increment();
  await Future.delayed(Duration.zero); // Wait for emission

  expect(states, [1]);
  await subscription.cancel();
  await cubit.close();
});

// ‚úÖ BLOC_TEST: Declarative, powerful testing
blocTest<CounterCubit, int>(
  'emits [1] when increment is called',
  build: () => CounterCubit(),
  act: (cubit) => cubit.increment(),
  expect: () => [1],
);
```

### 2. Code Generation - ELIMINATE BOILERPLATE

**THE PRINCIPLE:** Use code generation packages to eliminate repetitive code and ensure consistency.

#### **2.1. Freezed - IMMUTABLE DATA CLASSES**

```dart
// ‚ùå MANUAL DATA CLASS: Lots of boilerplate
class User {
  const User({
    required this.id,
    required this.name,
    this.email,
  });

  final String id;
  final String name;
  final String? email;

  User copyWith({
    String? id,
    String? name,
    String? email,
  }) {
    return User(
      id: id ?? this.id,
      name: name ?? this.name,
      email: email ?? this.email,
    );
  }

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is User &&
        other.id == id &&
        other.name == name &&
        other.email == email;
  }

  @override
  int get hashCode => Object.hash(id, name, email);
}

// ‚úÖ FREEZED: Zero boilerplate, maximum features
@freezed
class User with _$User {
  const factory User({
    required String id,
    required String name,
    String? email,
  }) = _User;

  factory User.fromJson(Map<String, Object?> json) => _$UserFromJson(json);
}
```

#### **2.2. Injectable + GetIt - DEPENDENCY INJECTION**

```dart
// ‚ùå MANUAL DI: Error-prone service registration
class ServiceLocator {
  static final GetIt _getIt = GetIt.instance;

  static void setup() {
    _getIt.registerFactory<UserRepository>(() => UserRepositoryImpl());
    _getIt.registerLazySingleton<ApiClient>(() => ApiClientImpl());
    _getIt.registerSingleton<Logger>(Logger());
    // Risk of typos, missing dependencies, wrong lifecycle
  }
}

// ‚úÖ INJECTABLE: Automatic dependency injection
@module
abstract class AppModule {
  @factoryMethod
  UserRepository get userRepository => UserRepositoryImpl();

  @lazySingleton
  ApiClient get apiClient => ApiClientImpl();

  @singleton
  Logger get logger => Logger();
}

@injectableInit
void configureDependencies() => getIt.init();
```

#### **2.3. Auto Route - TYPE-SAFE NAVIGATION**

```dart
// ‚ùå MANUAL ROUTING: String-based, error-prone
class AppRouter {
  static const String home = '/';
  static const String user = '/user';

  static Route<dynamic> generateRoute(RouteSettings settings) {
    switch (settings.name) {
      case home:
        return MaterialPageRoute(builder: (_) => HomePage());
      case user:
        final userId = settings.arguments as String;
        return MaterialPageRoute(builder: (_) => UserPage(userId: userId));
      default:
        return MaterialPageRoute(builder: (_) => NotFoundPage());
    }
  }
}

// ‚úÖ AUTO_ROUTE: Type-safe, declarative routing
@AutoRouterConfig()
class AppRouter extends _$AppRouter {
  @override
  List<AutoRoute> get routes => [
    AutoRoute(page: HomeRoute.page, path: '/'),
    AutoRoute(page: UserRoute.page, path: '/user/:userId'),
  ];
}

// Usage: Type-safe navigation
context.router.push(UserRoute(userId: '123'));
```

### 3. Functional Programming with FpDart - BULLETPROOF ERROR HANDLING

**THE PRINCIPLE:** Use functional programming patterns for safer, more predictable code.

#### **3.1. Either Type for Error Handling**

```dart
// ‚ùå MANUAL ERROR HANDLING: Exception-based, unpredictable
Future<User> getUser(String id) async {
  try {
    final response = await apiClient.get('/user/$id');
    return User.fromJson(response.data);
  } catch (e) {
    throw UserException('Failed to get user: $e');
  }
}

// Caller must remember to handle exceptions
try {
  final user = await getUser('123');
  print(user.name);
} catch (e) {
  print('Error: $e');
}

// ‚úÖ FPDART: Explicit, type-safe error handling
Future<Either<UserFailure, User>> getUser(String id) async {
  try {
    final response = await apiClient.get('/user/$id');
    final user = User.fromJson(response.data);
    return Right(user);
  } catch (e) {
    return Left(UserFailure.network(e.toString()));
  }
}

// Caller forced to handle both success and failure cases
final result = await getUser('123');
result.fold(
  (failure) => print('Error: ${failure.message}'),
  (user) => print('Success: ${user.name}'),
);
```

#### **3.2. Option Type for Nullable Values**

```dart
// ‚ùå MANUAL NULL HANDLING: Verbose null checks
String? getUserName(String? id) {
  if (id == null) return null;
  final user = users[id];
  if (user == null) return null;
  return user.name.isEmpty ? null : user.name;
}

// ‚úÖ FPDART: Elegant option chaining
Option<String> getUserName(String? id) {
  return Option.fromNullable(id)
      .flatMap((id) => Option.fromNullable(users[id]))
      .map((user) => user.name)
      .filter((name) => name.isNotEmpty);
}

// Usage with pattern matching
getUserName('123').match(
  () => print('No user name found'),
  (name) => print('User name: $name'),
);
```

### 4. Internationalization with Slang - TYPE-SAFE I18N

**THE PRINCIPLE:** Use type-safe internationalization instead of string-based approaches.

#### **4.1. Type-Safe Translations**

```dart
// ‚ùå MANUAL I18N: String-based, error-prone
class AppLocalizations {
  static String welcome(String name) => 'Welcome, $name!';
  static String itemCount(int count) =>
      count == 1 ? '1 item' : '$count items';
}

// ‚úÖ SLANG: Type-safe, compile-time checked
// translations.i18n.json:
// {
//   "welcome": "Welcome, {name}!",
//   "itemCount": {
//     "one": "1 item",
//     "other": "{count} items"
//   }
// }

// Generated code provides type safety:
Text(t.welcome(name: user.name))
Text(t.itemCount(count: items.length))
```

### 5. Environment Management with Envied - SECURE CONFIG

**THE PRINCIPLE:** Use compile-time environment variable management instead of runtime loading.

#### **5.1. Type-Safe Environment Variables**

```dart
// ‚ùå MANUAL ENV: Runtime loading, insecure
class Config {
  static String get apiUrl {
    const url = String.fromEnvironment('API_URL');
    if (url.isEmpty) throw StateError('API_URL not found');
    return url;
  }
}

// ‚úÖ ENVIED: Compile-time, obfuscated, type-safe
@Envied(path: '.env')
abstract class Env {
  @EnviedField(varName: 'API_URL', obfuscate: true)
  static const String apiUrl = _Env.apiUrl;

  @EnviedField(varName: 'DEBUG_MODE')
  static const bool debugMode = _Env.debugMode;
}
```

### 6. Testing with Smart Mocking - COMPREHENSIVE TESTING

**THE PRINCIPLE:** Use modern mocking and testing tools for reliable, maintainable tests.

#### **6.1. Mocktail for Modern Mocking**

```dart
// ‚ùå MANUAL MOCKING: Boilerplate-heavy
class MockUserRepository implements UserRepository {
  User? _mockUser;
  Exception? _mockError;

  void setMockUser(User user) => _mockUser = user;
  void setMockError(Exception error) => _mockError = error;

  @override
  Future<User> getUser(String id) async {
    if (_mockError != null) throw _mockError!;
    return _mockUser ?? throw StateError('No mock user set');
  }
}

// ‚úÖ MOCKTAIL: Clean, powerful mocking
class MockUserRepository extends Mock implements UserRepository {}

test('should return user when repository succeeds', () async {
  final mockRepo = MockUserRepository();
  final user = User(id: '1', name: 'John');

  when(() => mockRepo.getUser('1')).thenAnswer((_) async => user);

  final cubit = UserCubit(mockRepo);
  cubit.loadUser('1');

  verify(() => mockRepo.getUser('1')).called(1);
});
```

#### **6.2. BDD Widget Test for Behavioral Testing**

```dart
// ‚ùå MANUAL BEHAVIOR TESTING: Verbose, unclear intent
testWidgets('should show loading then user data', (tester) async {
  final mockCubit = MockUserCubit();

  when(() => mockCubit.state).thenReturn(UserLoading());

  await tester.pumpWidget(UserPage(cubit: mockCubit));

  expect(find.byType(CircularProgressIndicator), findsOneWidget);

  when(() => mockCubit.state).thenReturn(UserSuccess(user));
  mockCubit.emit(UserSuccess(user));

  await tester.pump();

  expect(find.text(user.name), findsOneWidget);
});

// ‚úÖ BDD_WIDGET_TEST: Natural language, clear scenarios
void main() {
  group('User Page', () {
    bddWidgetTest(
      'User sees loading indicator then user data',
      (WidgetTester tester) async {
        given('user page is displayed');
        when('user data is loading');
        then('loading indicator should be visible');
        and('when user data loads successfully');
        then('user name should be displayed');
      },
    );
  });
}
```

### 7. UI Development with Smart Packages - RESPONSIVE & CONSISTENT

#### **7.1. Flutter ScreenUtil for Responsive Design**

```dart
// ‚ùå MANUAL RESPONSIVE: Device-specific calculations
class ResponsiveHelper {
  static double getResponsiveWidth(BuildContext context, double width) {
    final screenWidth = MediaQuery.of(context).size.width;
    final devicePixelRatio = MediaQuery.of(context).devicePixelRatio;
    return width * screenWidth / 375.0; // Assuming 375 base width
  }
}

// ‚úÖ FLUTTER_SCREENUTIL: Automatic responsive calculations
// Initialize once in main()
ScreenUtil.init(
  context,
  designSize: Size(375, 812),
  minTextAdapt: true,
);

// Usage: Automatic scaling
Container(
  width: 200.w,        // Responsive width
  height: 100.h,       // Responsive height
  margin: EdgeInsets.all(16.r),  // Responsive margin
  child: Text(
    'Hello',
    style: TextStyle(fontSize: 18.sp),  // Responsive font size
  ),
)
```

#### **7.2. Google Fonts for Typography**

```dart
// ‚ùå MANUAL FONTS: Asset management, platform variations
class AppFonts {
  static const TextStyle bodyText = TextStyle(
    fontFamily: 'Roboto',  // Must manage font files
    fontSize: 16,
    fontWeight: FontWeight.normal,
  );
}

// ‚úÖ GOOGLE_FONTS: Automatic font management
Text(
  'Beautiful Typography',
  style: GoogleFonts.roboto(  // Automatic font loading
    fontSize: 16.sp,
    fontWeight: FontWeight.w400,
  ),
)

// Theme integration
ThemeData(
  textTheme: GoogleFonts.robotoTextTheme(),
  primaryTextTheme: GoogleFonts.openSansTextTheme(),
)
```

### 8. Component Development with Widgetbook - ISOLATED TESTING

**THE PRINCIPLE:** Use Widgetbook for component-driven development and visual testing.

#### **8.1. Widgetbook for Component Showcase**

```dart
// ‚ùå MANUAL COMPONENT TESTING: Full app required
void main() {
  runApp(MaterialApp(
    home: Scaffold(
      body: Column(
        children: [
          CustomButton(text: 'Primary'),
          CustomButton(text: 'Secondary', variant: ButtonVariant.secondary),
          // Hard to test all variations
        ],
      ),
    ),
  ));
}

// ‚úÖ WIDGETBOOK: Isolated component development
@UseCase(name: 'Default', type: CustomButton)
Widget defaultButton(BuildContext context) {
  return CustomButton(
    text: context.knobs.string(label: 'Text', initialValue: 'Click me'),
    variant: context.knobs.list(
      label: 'Variant',
      options: ButtonVariant.values,
    ),
    isEnabled: context.knobs.boolean(label: 'Enabled', initialValue: true),
  );
}

// Automatic component catalog with live knobs
class WidgetbookApp extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Widgetbook.material(
      directories: [
        WidgetbookFolder(
          name: 'Buttons',
          children: [
            WidgetbookComponent(
              name: 'CustomButton',
              useCases: [
                WidgetbookUseCase(
                  name: 'Default',
                  builder: defaultButton,
                ),
              ],
            ),
          ],
        ),
      ],
    );
  }
}
```

### 9. Performance Optimization with Smart Package Usage

#### **9.1. Equatable for Efficient Comparisons**

```dart
// ‚ùå MANUAL EQUALITY: Error-prone, performance issues
class User {
  const User({required this.id, required this.name});

  final String id;
  final String name;

  @override
  bool operator ==(Object other) {
    if (identical(this, other)) return true;
    return other is User && other.id == id && other.name == name;
    // Easy to forget fields or make mistakes
  }

  @override
  int get hashCode => Object.hash(id, name);
}

// ‚úÖ EQUATABLE: Automatic, efficient equality
class User extends Equatable {
  const User({required this.id, required this.name});

  final String id;
  final String name;

  @override
  List<Object?> get props => [id, name];  // Automatic equality
}
```

### 10. Development Workflow Acceleration

#### **10.1. Build Runner Commands - SMART GENERATION**

```bash
# ‚ùå MANUAL: Running individual generators
flutter pub run freezed
flutter pub run json_serializable
flutter pub run auto_route_generator
flutter pub run injectable_generator

# ‚úÖ BUILD_RUNNER: Unified code generation
dart run build_runner build --delete-conflicting-outputs
dart run build_runner watch  # Continuous generation during development
```

#### **10.2. Smart Build Configuration**

```yaml
# build.yaml - Optimize generation performance
targets:
  $default:
    builders:
      freezed:
        generate_for:
          - lib/core/models/*.dart
          - lib/features/*/models/*.dart
      injectable_generator:
        generate_for:
          - lib/core/injection.dart
      auto_route_generator:
        generate_for:
          - lib/core/routing/app_router.dart
```

## üö® Critical Rules to Prevent Linter Errors

> **ZERO TOLERANCE POLICY**: No linting errors, no warnings, no exceptions. Every issue must be resolved before commit.

**Priority Order for Quick Fixes:**

1. üî• **cascade_invocations** - Use `..` for instance methods, records `()` for static methods
2. üî• **public_member_api_docs** - Add `/// documentation` to all public APIs
3. üî• **lines_longer_than_80_chars** - Break long lines immediately
4. üî• **avoid_catches_without_on_clauses** - Use `on` clause in catch blocks
5. üî• **prefer_const_constructors** - Add `const` wherever possible
6. üî• **avoid_print** - Replace with `Console.info()` or proper logging
7. üî• **deprecated_member_use** - Replace deprecated Color.value and Color.alpha usage

### 1. Cascade Operators (`..`) - MANDATORY for Multiple Calls

**THE GOLDEN RULE:** Use cascade operators when calling 2+ methods on the same object instance.

```dart
// ‚ùå LINT ERROR: cascade_invocations
final logger = Logger(printer: SimplePrinter());
logger.e('Error message 1');
logger.e('Error message 2');
logger.e('Error message 3');

// ‚úÖ CORRECT: Use cascade operators
Logger(printer: SimplePrinter())
  ..e('Error message 1')
  ..e('Error message 2')
  ..e('Error message 3');

// ‚ùå SPECIAL CASE: Static methods (cascade won't work)
EnvConfigFactory.apiUrl;
EnvConfigFactory.appName;
EnvConfigFactory.environmentName;

// ‚úÖ SOLUTION: Use records for grouping static calls
final _ = (
  EnvConfigFactory.apiUrl,
  EnvConfigFactory.appName,
  EnvConfigFactory.environmentName,
);
```

**Rules:**

- **Instance methods (2+ calls)** ‚Üí Use cascade operators (`..`)
- **Instance methods (1 call)** ‚Üí Use dot notation (`.`)
- **Static methods (multiple calls)** ‚Üí Use records `()` or meaningful variables
- **Static methods (single call)** ‚Üí Direct access

### 2. Documentation - MANDATORY for Public APIs

**ALL public members MUST have documentation** to avoid `public_member_api_docs` errors.

```dart
// ‚ùå LINT ERROR: Missing documentation
class CounterCubit extends Cubit<int> {
  CounterCubit() : super(0);
  void increment() => emit(state + 1);
}

// ‚úÖ CORRECT: Document all public APIs
/// A cubit that manages a counter state with increment and decrement operations.
class CounterCubit extends Cubit<int> {
  /// Creates a CounterCubit with initial state of 0.
  CounterCubit() : super(0);

  /// Increments the counter value by 1.
  void increment() => emit(state + 1);
}
```

**Documentation Templates for Common Patterns:**

```dart
// ‚úÖ SEALED CLASS DOCUMENTATION
/// Sealed class representing different application environments.
///
/// This class provides a factory pattern for environment-specific
/// configurations and ensures type safety when switching between
/// development, staging, and production.
sealed class Environment {
  /// Creates an instance of Environment.
  const Environment();

  /// Gets the current environment instance based on compile-time
  /// configuration.
  static Environment get current => _getCurrentEnvironment();

  /// The API base URL for this environment.
  String get apiUrl;

  /// The application name for this environment.
  String get appName;
}

// ‚úÖ FACTORY CLASS DOCUMENTATION
/// Factory class for accessing environment configuration.
///
/// Provides static methods to access current environment settings
/// and utilities for environment-specific operations.
class EnvConfigFactory {
  /// Gets the current environment instance.
  static Environment get currentEnvironment => Environment.current;

  /// Gets the API URL from the current environment.
  static String get apiUrl => currentEnvironment.apiUrl;

  /// Gets the API URL for a specific environment.
  ///
  /// [environment] The environment to get the API URL from.
  static String getApiUrlForEnvironment(Environment environment) =>
      environment.apiUrl;
}

// ‚úÖ IMPLEMENTATION CLASS DOCUMENTATION
/// Development environment configuration.
///
/// Provides configuration values specific to development environment.
final class Development extends Environment {
  /// Creates a development environment instance.
  const Development();

  @override
  String get apiUrl => EnvDev.apiUrl;
}

// ‚úÖ REPOSITORY IMPLEMENTATION DOCUMENTATION
/// Implementation of [EnvConfigRepository] that provides environment
/// configuration through [EnvConfigFactory].
///
/// This repository acts as a bridge between the domain layer and the
/// infrastructure layer, delegating configuration access to the factory.
class EnvConfigRepositoryImpl implements EnvConfigRepository {
  @override
  String get apiUrl => EnvConfigFactory.apiUrl;
}
```

**Auto-Documentation Rules:**

- **Classes/Interfaces**: What they represent and their primary purpose
- **Methods**: What they do and their parameters (use `[paramName]` syntax)
- **Properties**: What they represent or contain
- **Constructors**: What they create and initial state
- **Factory methods**: What they return and when to use them
- **Static methods**: Their purpose and when to call them

### 3. Naming Conventions - Strict Enforcement

```dart
// ‚úÖ CORRECT: Naming patterns
class UserRepository {}        // PascalCase for classes
final userName = 'John';       // camelCase for variables
void getUserData() {}          // camelCase for methods
const maxRetries = 3;          // camelCase for constants (NOT SCREAMING_SNAKE_CASE)

// File names: snake_case
user_repository.dart
counter_cubit.dart
```

### 4. Import Organization - Prevent unused_import Errors

```dart
// ‚úÖ CORRECT: Organized imports (dart_code_metrics order)
import 'dart:async';           // Dart core
import 'dart:developer';

import 'package:bloc/bloc.dart';      // External packages
import 'package:flutter/material.dart';

import 'package:xp1/counter/counter.dart';  // Internal packages
import 'package:xp1/l10n/l10n.dart';
```

### 5. Const Constructors - MANDATORY When Possible

```dart
// ‚ùå LINT ERROR: prefer_const_constructors
class MyWidget extends StatelessWidget {
  MyWidget({super.key});  // Missing const

  @override
  Widget build(BuildContext context) {
    return Text('Hello');  // Missing const
  }
}

// ‚úÖ CORRECT: Use const constructors
class MyWidget extends StatelessWidget {
  const MyWidget({super.key});

  @override
  Widget build(BuildContext context) {
    return const Text('Hello');
  }
}
```

### 6. Line Length - 80 Characters Maximum

```dart
// ‚ùå LINT ERROR: lines_longer_than_80_chars
expect(EnvConfigFactory.getAppNameForEnvironment(const Development()), equals('XP1 Development'));

// ‚úÖ CORRECT: Break long lines appropriately
expect(
  EnvConfigFactory.getAppNameForEnvironment(const Development()),
  equals('XP1 Development'),
);
```

#### **6.1. Comment Line Breaking - CRITICAL for Test Files**

**THE GOLDEN RULE**: Comments must NEVER exceed 80 characters. Break them cleanly at logical points.

```dart
// ‚ùå LINT ERROR: Comment exceeds 80 characters
// Initialize Flutter test bindings and mock platform storage before any DI work
void main() {
  // Call parent fromJson with data that will cause LocaleConfiguration.fromJson
  // to throw an Exception (not Error)
  final result = cubit.testMethod();
}

// ‚úÖ CORRECT: Break comments at logical points
// Initialize Flutter test bindings and mock platform storage before any
// DI work
void main() {
  // Call parent fromJson with data that will cause
  // LocaleConfiguration.fromJson
  // to throw an Exception (not Error)
  final result = cubit.testMethod();
}
```

**Comment Breaking Patterns:**

```dart
// ‚ùå WRONG: Single line comment over 80 chars
// Test through public API since private methods aren't directly accessible

// ‚úÖ CORRECT: Break at logical word boundaries
// Test through public API since private methods aren't directly
// accessible

// ‚ùå WRONG: Breaking at arbitrary points
// This will force a real Exception (not Error) in LocaleConfiguration.
// fromJson

// ‚úÖ CORRECT: Break at class/method boundaries
// This will force a real Exception (not Error) in
// LocaleConfiguration.fromJson

// ‚ùå WRONG: Method calls split awkwardly
bool containsKey(Object? key) => true; // Return true so it gets to the operator[]

// ‚úÖ CORRECT: Break before inline comment or restructure
bool containsKey(Object? key) =>
    true; // Return true so it gets to the operator[]

// ‚úÖ ALTERNATIVE: Move comment above
// Return true so it gets to the operator[]
bool containsKey(Object? key) => true;
```

**üí° Comment Breaking Strategy Guide:**

```dart
// üéØ STRATEGY 1: Break at natural word boundaries
// ‚ùå Long: "This function handles complex user authentication and authorization processes"
// ‚úÖ Fixed: "This function handles complex user authentication and authorization
//           processes"

// üéØ STRATEGY 2: Break at conjunctions (and, or, but, so, etc.)
// ‚ùå Long: "This validates input data and returns proper error messages if validation fails"
// ‚úÖ Fixed: "This validates input data and returns proper error messages if
//           validation fails"

// üéØ STRATEGY 3: Break at prepositions (in, on, at, for, with, etc.)
// ‚ùå Long: "This step verifies that unsupported language attempts are handled gracefully"
// ‚úÖ Fixed: "This step verifies that unsupported language attempts are handled
//           gracefully"

// üéØ STRATEGY 4: Break at technical terms/class names
// ‚ùå Long: "For BDD testing, we verify that the state is properly configured for persistence"
// ‚úÖ Fixed: "For BDD testing, we verify that the state is properly configured for
//           persistence"

// üéØ STRATEGY 5: Use parallel structure for multi-line comments
// ‚úÖ GOOD: Consistent indentation and parallel structure
// This method accomplishes several important tasks:
// - Validates user input according to business rules
// - Transforms data into the required format
// - Handles edge cases and error conditions gracefully
```

**Test File Comment Patterns:**

```dart
// ‚ùå COMMON MISTAKE: Long setup/teardown comments
// Initialize Flutter test bindings and mock platform storage before any DI work

// ‚úÖ CORRECT: Break at logical boundaries
// Initialize Flutter test bindings and mock platform storage before any
// DI work

// ‚ùå COMMON MISTAKE: Long test descriptions as inline comments
test('should handle edge case', () {
  // This test verifies that the system properly handles the edge case where user input is malformed
});

// ‚úÖ CORRECT: Break long explanatory comments
test('should handle edge case', () {
  // This test verifies that the system properly handles the edge case
  // where user input is malformed
});

// ‚úÖ ALTERNATIVE: Use test description for clarity
test(
  'should handle edge case where user input is malformed',
  () {
    // Test implementation
  },
);
```

**BDD Test Step Comment Patterns:**

```dart
// ‚ùå BDD MISTAKE: Long explanation comments
// This step verifies that unsupported language attempts are handled gracefully
// For BDD testing, we verify that the state is properly configured for persistence

// ‚úÖ BDD CORRECT: Break at logical word boundaries
// This step verifies that unsupported language attempts are handled
// gracefully
// For BDD testing, we verify that the state is properly configured for
// persistence

// ‚ùå BDD MISTAKE: Long verification explanations
// The LocaleCubit should return errors for invalid locales, and the app should remain stable

// ‚úÖ BDD CORRECT: Break complex verification logic
// The LocaleCubit should return errors for invalid locales, and the app
// should remain stable

// ‚úÖ BDD PATTERN: Multi-step explanations
// In a real app restart test, you would:
// 1. Store the current state
// 2. Restart the app (or create new widget tree)
// 3. Verify the state is restored
```

**VS Code Line Length Helpers:**

```json
{
  "editor.rulers": [80],
  "editor.wordWrap": "bounded",
  "editor.wordWrapColumn": 80,
  "dart.lineLength": 80
}
```

### 7. Flutter 3.27+ Color Deprecation Guidelines - MANDATORY

**CRITICAL**: Flutter 3.27.0+ deprecated `Color.value` and `Color.alpha` for wide gamut color support.

#### **7.1. Replace Color.value with toARGB32()**

```dart
// ‚ùå DEPRECATED: Color.value (Flutter 3.27+)
int colorValue = myColor.value;
expect(color.value, equals(0xFF2196F3));

// ‚úÖ CORRECT: Use toARGB32() for explicit conversion
int colorValue = myColor.toARGB32();
expect(color.toARGB32(), equals(0xFF2196F3));
```

#### **7.2. Replace Color.alpha with Component Accessors**

```dart
// ‚ùå DEPRECATED: Color.alpha (Flutter 3.27+)
int alphaValue = color.alpha;
expect(color.alpha, equals(255));

// ‚úÖ CORRECT: Use component accessor with conversion
int alphaValue = (color.a * 255.0).round() & 0xff;
expect((color.a * 255.0).round() & 0xff, equals(255));
```

#### **7.3. Use Component Accessors for Color Values**

```dart
// ‚ùå DEPRECATED: Old component accessors
int redValue = color.red;
int greenValue = color.green;
int blueValue = color.blue;

// ‚úÖ CORRECT: New floating-point component accessors
double redComponent = color.r;     // 0.0-1.0 range
double greenComponent = color.g;   // 0.0-1.0 range
double blueComponent = color.b;    // 0.0-1.0 range
double alphaComponent = color.a;   // 0.0-1.0 range

// ‚úÖ CORRECT: Convert to integer when needed
int redInt = (color.r * 255.0).round() & 0xff;
int greenInt = (color.g * 255.0).round() & 0xff;
int blueInt = (color.b * 255.0).round() & 0xff;
int alphaInt = (color.a * 255.0).round() & 0xff;
```

#### **7.4. Color Conversion Utilities**

```dart
// ‚úÖ HELPER: Extension for easy integer conversion
extension IntColorComponents on Color {
  int get intAlpha => (a * 255.0).round() & 0xff;
  int get intRed => (r * 255.0).round() & 0xff;
  int get intGreen => (g * 255.0).round() & 0xff;
  int get intBlue => (b * 255.0).round() & 0xff;
}

// Usage:
final color = Colors.blue;
expect(color.intRed, equals(33));    // Blue color red component
expect(color.intAlpha, equals(255)); // Fully opaque
```

#### **7.5. Test File Color Comparisons**

```dart
// ‚ùå DEPRECATED: In test files
expect(lerped.primary.value, closeTo(expectedGrey.value, 0x010101));
expect(color.alpha, equals(255));

// ‚úÖ CORRECT: In test files
expect(lerped.primary.toARGB32(), closeTo(expectedGrey.toARGB32(), 0x010101));
expect((color.a * 255.0).round() & 0xff, equals(255));
```

#### **7.6. MaterialColor Creation**

```dart
// ‚úÖ CORRECT: Create MaterialColor with toARGB32()
MaterialColor createMaterialColor(Color color) {
  final List<double> strengths = <double>[.05];
  final Map<int, Color> swatch = {};

  for (var i = 1; i < 10; i++) {
    strengths.add(0.1 * i);
  }

  for (final strength in strengths) {
    final double ds = 0.5 - strength;
    swatch[(strength * 1000).round()] = Color.fromRGBO(
      (color.r + ((ds < 0 ? color.r : (1 - color.r)) * ds)).clamp(0.0, 1.0),
      (color.g + ((ds < 0 ? color.g : (1 - color.g)) * ds)).clamp(0.0, 1.0),
      (color.b + ((ds < 0 ? color.b : (1 - color.b)) * ds)).clamp(0.0, 1.0),
      1,
    );
  }

  // Use toARGB32() instead of value
  return MaterialColor(color.toARGB32(), swatch);
}
```

#### **7.7. ‚ö° Color Deprecation Prevention Checklist**

**Before writing any Color-related code, remember:**

- ‚úÖ **ALWAYS** use `color.toARGB32()` instead of `color.value`
- ‚úÖ **ALWAYS** use `(color.a * 255.0).round() & 0xff` instead of `color.alpha`
- ‚úÖ **Test files**: Replace `.value` with `.toARGB32()` in all `expect()` statements
- ‚úÖ **Line length**: Break long color comparisons with proper indentation
- ‚ùå **NEVER** use deprecated `Color.value` or `Color.alpha` properties

**Quick Search & Replace for Mass Fixes:**

```bash
# Find all Color.value usage
grep -r "\.value" test/ lib/

# Replace pattern in test files
sed -i '' 's/\.value/.toARGB32()/g' test/**/*.dart
```

### 8. Error Handling - Specific Exception Classes

```dart
// ‚ùå AVOID: Generic exceptions
throw Exception('User not found');

// ‚úÖ CORRECT: Specific exception classes
class UserNotFoundException implements Exception {
  const UserNotFoundException(this.userId);
  final String userId;

  @override
  String toString() => 'UserNotFoundException: User with ID $userId not found';
}

throw UserNotFoundException(userId);
```

#### **7.1. Catch Clauses - MANDATORY Use of 'on' Clause**

**THE GOLDEN RULE**: Always specify the exception type using `on` clause in catch blocks to avoid `avoid_catches_without_on_clauses` errors.

```dart
// ‚ùå LINT ERROR: avoid_catches_without_on_clauses
try {
  await someOperation();
} catch (e) {
  // Generic catch - linter error
  handleError(e);
}

// ‚úÖ CORRECT: Specific exception catching
try {
  await someOperation();
} on BootstrapException catch (e) {
  // Specific exception type
  handleBootstrapError(e);
} on Exception catch (e) {
  // More general but still typed
  handleGenericError(e);
}

// ‚úÖ BEST PRACTICE: Multiple specific catches
try {
  await userService.updateUser(user);
} on UserNotFoundException catch (e) {
  showUserNotFoundError(e.userId);
} on ValidationException catch (e) {
  showValidationErrors(e.errors);
} on NetworkException catch (e) {
  showNetworkError(e.message);
}
```

**Common Test Patterns:**

```dart
// ‚ùå WRONG: Generic catch in tests
try {
  await service.methodThatShouldThrow();
  fail('Expected SomeException');
} catch (e) {
  expect(e, isA<SomeException>());
  final exception = e as SomeException;
}

// ‚úÖ CORRECT: Specific catch in tests
try {
  await service.methodThatShouldThrow();
  fail('Expected SomeException');
} on SomeException catch (e) {
  expect(e, isA<SomeException>());
  final exception = e; // No casting needed
}

// ‚úÖ ALTERNATIVE: Use expectLater for cleaner tests
expect(
  () => service.methodThatShouldThrow(),
  throwsA(isA<SomeException>()),
);
```

**Exception Hierarchy Guidelines:**

- **Specific first**: Catch most specific exceptions first
- **General last**: Use `Exception` as fallback, not `Object` or generic catch
- **Re-throw when needed**: Use `rethrow;` to preserve stack trace
- **Document exceptions**: Always document what exceptions methods can throw

### 8. Widget Structure - Performance Optimized

```dart
// ‚ùå PERFORMANCE ISSUE: Unnecessary rebuilds
class CounterText extends StatelessWidget {
  const CounterText({super.key});

  @override
  Widget build(BuildContext context) {
    final cubit = context.read<CounterCubit>();  // ‚ùå Will not rebuild
    return Text('${cubit.state}');
  }
}

// ‚úÖ CORRECT: Selective rebuilds
class CounterText extends StatelessWidget {
  const CounterText({super.key});

  @override
  Widget build(BuildContext context) {
    final count = context.select((CounterCubit cubit) => cubit.state);
    return Text('$count');
  }
}
```

### 9. Test Structure - Comprehensive Coverage

```dart
// ‚úÖ CORRECT: Test structure with proper setup/teardown
void main() {
  group('CounterCubit', () {
    late CounterCubit counterCubit;

    setUp(() {
      counterCubit = CounterCubit();
    });

    tearDown(() {
      counterCubit.close();
    });

    test('initial state is 0', () {
      expect(counterCubit.state, equals(0));
    });
  });
}
```

### 10. Memory Management - Prevent Leaks

```dart
// ‚úÖ CORRECT: Proper disposal
class _MyWidgetState extends State<MyWidget> {
  late Timer _timer;

  @override
  void initState() {
    super.initState();
    _timer = Timer.periodic(const Duration(seconds: 1), (_) {});
  }

  @override
  void dispose() {
    _timer.cancel();  // ‚ùå CRITICAL: Always dispose resources
    super.dispose();
  }
}
```

## üîß Quick Fixes for Common Linter Errors

### avoid_print ‚Üí Use proper console output

```dart
// ‚ùå avoid_print
print('Debug message');

// ‚úÖ Use Console class or log
Console.info('Debug message');
log('Debug message');
```

### prefer_final_locals ‚Üí Use final when possible

```dart
// ‚ùå prefer_final_locals
String message = 'Hello';

// ‚úÖ Use final
final message = 'Hello';
```

### unused_field ‚Üí Remove or use declared fields

```dart
// ‚ùå unused_field
class AppBootstrap {
  AppBootstrap({PlatformLocaleProvider? platformProvider})
    : _platformProvider = platformProvider;

  final PlatformLocaleProvider? _platformProvider; // ‚ùå Never used

  void bootstrap() {
    // _platformProvider is never referenced
  }
}

// ‚úÖ OPTION 1: Remove unused field
class AppBootstrap {
  const AppBootstrap();

  void bootstrap() {
    // Clean implementation
  }
}

// ‚úÖ OPTION 2: Use the field
class AppBootstrap {
  AppBootstrap({PlatformLocaleProvider? platformProvider})
    : _platformProvider = platformProvider;

  final PlatformLocaleProvider? _platformProvider;

  void bootstrap() {
    final provider = _platformProvider ?? DefaultPlatformProvider();
    // Use the provider
  }
}
```

### unnecessary_underscores ‚Üí Use single underscore for unused parameters

```dart
// ‚ùå unnecessary_underscores
return when(
  success: (data, __) => 'Success',
  error: (message, __) => 'Error: $message',
  loading: (__, ___) => 'Loading...',
);

// ‚úÖ Use single underscore
return when(
  success: (data, _) => 'Success',
  error: (message, _) => 'Error: $message',
  loading: (_, _) => 'Loading...',
);
```

### unnecessary_statements ‚Üí Avoid meaningless expressions

```dart
// ‚ùå unnecessary_statements
final hasContent = checkForContent();
// This line does nothing
hasContent;

// ‚úÖ OPTION 1: Remove if truly unused
final hasContent = checkForContent();
// Don't reference it if not needed

// ‚úÖ OPTION 2: Assign to underscore if suppressing warnings
final hasContent = checkForContent();
// ignore: unused_local_variable
final _ = hasContent;
```

### depend_on_referenced_packages ‚Üí Declare all imported packages

```dart
// ‚ùå depend_on_referenced_packages
// File: my_package/lib/example.dart
import 'package:shared_preferences/shared_preferences.dart'; // ‚ùå Not in pubspec.yaml

// ‚úÖ Add to pubspec.yaml (alphabetically sorted)
dependencies:
  flutter:
    sdk: flutter
  shared_preferences: ^2.3.4  # ‚úÖ Added dependency
```

### invalid_use_of_visible_for_testing_member ‚Üí Proper testing member usage

```dart
// ‚ùå Using testing member outside test context
void setup() {
  SharedPreferences.setMockInitialValues({}); // ‚ùå Only for tests
}

// ‚úÖ OPTION 1: Use in actual test files (test/ directory)
// File: test/my_test.dart
void setUp() {
  SharedPreferences.setMockInitialValues({});
}

// ‚úÖ OPTION 2: Suppress warning for BDD/integration tests
void setupBddTest() {
  // ignore: invalid_use_of_visible_for_testing_member
  SharedPreferences.setMockInitialValues({});
}
```

### unnecessary_lambdas ‚Üí Use tear-offs

```dart
// ‚ùå unnecessary_lambdas
items.map((e) => e.toString())

// ‚úÖ Use tear-off
items.map(Object.toString)
```

### prefer_function_declarations_over_variables

```dart
// ‚ùå prefer_function_declarations_over_variables
final builder = () => const MockApp();

// ‚úÖ Use function declaration
MockApp builder() => const MockApp();
```

### omit_local_variable_types ‚Üí Omit obvious type annotations

```dart
// ‚ùå omit_local_variable_types
for (int i = 0; i < 1000; i++) {
  // code here
}

// ‚úÖ Use type inference
for (var i = 0; i < 1000; i++) {
  // code here
}
```

## üî• Real-World Error Patterns & Solutions

### Repository Pattern Implementation Fixes

```dart
// ‚ùå LINT ERROR: Missing documentation + cascade_invocations
class EnvConfigRepositoryImpl implements EnvConfigRepository {
  @override
  String get apiUrl => EnvConfigFactory.apiUrl;
  @override
  String get appName => EnvConfigFactory.appName;
  @override
  String get environmentName => EnvConfigFactory.environmentName;
}

// ‚úÖ CORRECT: Documented implementation
/// Implementation of [EnvConfigRepository] that provides environment
/// configuration through [EnvConfigFactory].
///
/// This repository acts as a bridge between the domain layer and the
/// infrastructure layer, delegating configuration access to the factory.
class EnvConfigRepositoryImpl implements EnvConfigRepository {
  @override
  String get apiUrl => EnvConfigFactory.apiUrl;
  @override
  String get appName => EnvConfigFactory.appName;
  @override
  String get environmentName => EnvConfigFactory.environmentName;
}
```

### Test File Common Issues & Solutions

```dart
// ‚ùå MULTIPLE LINT ERRORS: Line length + cascade_invocations + type annotation
test('should cache environment properties for fast access', () {
  // This test will FAIL - current implementation calls static getters repeatedly
  final stopwatch = Stopwatch()..start();

  for (int i = 0; i < 1000; i++) {
    EnvConfigFactory.apiUrl;
    EnvConfigFactory.appName;
    EnvConfigFactory.environmentName;
  }
});

// ‚úÖ CORRECT: Fixed all issues
test('should cache environment properties for fast access', () {
  // This test will FAIL - current implementation calls static getters
  // repeatedly
  final stopwatch = Stopwatch()..start();

  for (var i = 0; i < 1000; i++) {
    // Use records to group static method calls
    final _ = (
      EnvConfigFactory.apiUrl,
      EnvConfigFactory.appName,
      EnvConfigFactory.environmentName,
    );
  }
});

// ‚ùå LINT ERROR: Line length in group descriptions
group('Repository Pattern Integration (TDD Red Phase - These should FAIL)', () {

// ‚úÖ CORRECT: Break long group descriptions
group(
  'Repository Pattern Integration (TDD Red Phase - These should FAIL)',
  () {
```

### Performance Testing Patterns

```dart
// ‚ùå WRONG: Static calls without grouping (cascade_invocations)
for (var i = 0; i < 1000; i++) {
  EnvConfigFactory.apiUrl;
  EnvConfigFactory.appName;
  EnvConfigFactory.environmentName;
}

// ‚úÖ CORRECT: Group static calls with records
for (var i = 0; i < 1000; i++) {
  final _ = (
    EnvConfigFactory.apiUrl,
    EnvConfigFactory.appName,
    EnvConfigFactory.environmentName,
  );
}

// ‚úÖ ALTERNATIVE: Use meaningful variables when records don't make sense
for (var i = 0; i < 1000; i++) {
  final apiUrl = EnvConfigFactory.apiUrl;
  final appName = EnvConfigFactory.appName;
  final envName = EnvConfigFactory.environmentName;

  // Use the variables here
  expect(apiUrl, isNotEmpty);
  expect(appName, contains('XP1'));
  expect(envName, isNotEmpty);
}
```

## üéØ VS Code Settings for Auto-Fix

Ensure your `.vscode/settings.json` includes:

```json
{
  "dart.lineLength": 80,
  "editor.formatOnSave": true,
  "editor.rulers": [80],
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit",
    "source.organizeImports": "explicit"
  }
}
```

## ‚ö° Commands to Keep Code Clean

```bash
# Format code
dart format lib/ test/ --set-exit-if-changed

# Analyze for issues
dart analyze --fatal-infos

# Run tests with coverage
flutter test --coverage

# Check very_good_analysis compliance
very_good test --coverage
```

## üìÅ File Organization & Naming

### Directory Structure Standards

```
feature_name/
‚îú‚îÄ‚îÄ cubit/
‚îÇ   ‚îú‚îÄ‚îÄ feature_cubit.dart
‚îÇ   ‚îî‚îÄ‚îÄ feature_state.dart
‚îú‚îÄ‚îÄ view/
‚îÇ   ‚îú‚îÄ‚îÄ feature_page.dart
‚îÇ   ‚îî‚îÄ‚îÄ widgets/
‚îú‚îÄ‚îÄ models/
‚îÇ   ‚îî‚îÄ‚îÄ feature_model.dart
‚îî‚îÄ‚îÄ feature.dart  # Barrel export
```

### Widget Architecture Standards

#### 3-Layer Widget Organization

```
lib/
‚îú‚îÄ‚îÄ core/widgets/                   # üîß INFRASTRUCTURE LAYER
‚îÇ   ‚îú‚îÄ‚îÄ responsive_initializer.dart # Global responsive setup
‚îÇ   ‚îú‚îÄ‚îÄ base_scaffold.dart         # Framework utilities
‚îÇ   ‚îî‚îÄ‚îÄ loading_overlay.dart       # App-wide utilities
‚îú‚îÄ‚îÄ shared/widgets/                # üß± BUSINESS LAYER (Atomic Design)
‚îÇ   ‚îú‚îÄ‚îÄ atoms/                     # Basic reusable components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_button.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ custom_input.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ custom_card.dart
‚îÇ   ‚îú‚îÄ‚îÄ molecules/                 # Composite components
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ search_bar.dart
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ user_avatar.dart
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ stats_card.dart
‚îÇ   ‚îî‚îÄ‚îÄ organisms/                 # Complex sections
‚îÇ       ‚îú‚îÄ‚îÄ navigation_drawer.dart
‚îÇ       ‚îî‚îÄ‚îÄ header_section.dart
‚îî‚îÄ‚îÄ features/*/widgets/            # üè† FEATURE-SPECIFIC
    ‚îî‚îÄ‚îÄ feature_specific_widget.dart
```

#### Widget Layer Rules

**CORE WIDGETS (Infrastructure Layer):**

- ‚úÖ Framework-level utilities (`ResponsiveInitializer`, `BaseScaffold`)
- ‚úÖ App-wide cross-cutting concerns (`LoadingOverlay`, `ErrorBoundary`)
- ‚úÖ Low-level platform abstractions
- ‚ùå No business logic or domain knowledge
- ‚ùå No feature-specific styling

**SHARED WIDGETS (Business Layer - Atomic Design):**

- ‚úÖ Reusable business components following Atomic Design
- ‚úÖ `atoms/`: Basic UI elements (`CustomButton`, `CustomInput`)
- ‚úÖ `molecules/`: Composite components (`SearchBar`, `UserAvatar`)
- ‚úÖ `organisms/`: Complex sections (`NavigationDrawer`, `HeaderSection`)
- ‚úÖ Cross-feature reusability
- ‚ùå No feature-specific business logic

**FEATURE WIDGETS (Feature Layer):**

- ‚úÖ Feature-specific UI components
- ‚úÖ Tightly coupled to feature domain logic
- ‚úÖ Can use shared widgets as building blocks
- ‚ùå No cross-feature dependencies

#### Widget Creation Guidelines

**Naming Conventions for Widgets:**

```dart
// ‚úÖ CORRECT: Widget naming patterns
class CustomButton extends StatelessWidget {}      // atoms/
class SearchBar extends StatelessWidget {}         // molecules/
class NavigationDrawer extends StatelessWidget {}  // organisms/
class HomePageHeader extends StatelessWidget {}    // feature-specific

// ‚ùå WRONG: Inconsistent naming
class Button extends StatelessWidget {}           // Too generic
class UserSearchWidget extends StatelessWidget {} // Redundant "Widget"
```

**Widget Documentation Standards:**

````dart
// ‚úÖ CORRECT: Atomic Design widget documentation
/// A reusable button component that follows the design system.
///
/// This is an atomic component that can be used across features.
/// Supports different variants, sizes, and states.
///
/// Example:
/// ```dart
/// CustomButton(
///   text: 'Click me',
///   onPressed: () => print('Pressed'),
///   variant: ButtonVariant.primary,
/// )
/// ```
class CustomButton extends StatelessWidget {
  /// Creates a custom button with the specified properties.
  const CustomButton({
    required this.text,
    required this.onPressed,
    super.key,
    this.variant = ButtonVariant.primary,
  });

  /// The text to display on the button.
  final String text;

  /// Called when the button is pressed.
  final VoidCallback onPressed;

  /// The visual variant of the button.
  final ButtonVariant variant;
}
````

### File Naming Rules

```dart
// ‚úÖ CORRECT: snake_case for files
user_repository.dart
counter_cubit.dart
env_config_factory.dart

// ‚ùå WRONG: PascalCase or camelCase for files
UserRepository.dart
counterCubit.dart
```

## üé® Advanced Formatting Rules

### Complex Widget Breaking

```dart
// ‚ùå TOO LONG: Single line widget construction
return BlocProvider(create: (_) => CounterCubit(), child: CounterView());

// ‚úÖ CORRECT: Proper widget breaking
return BlocProvider(
  create: (_) => CounterCubit(),
  child: const CounterView(),
);

// ‚úÖ CORRECT: Complex nested widgets
return Scaffold(
  appBar: AppBar(
    title: Text(l10n.counterAppBarTitle),
    backgroundColor: Theme.of(context).primaryColor,
  ),
  body: const Center(
    child: CounterText(),
  ),
);
```

### Method Chaining & Fluent APIs

```dart
// ‚ùå TOO LONG: Single line chaining
final result = repository.getUser(id).then((user) => user.updateProfile()).catchError((error) => handleError(error));

// ‚úÖ CORRECT: Break fluent chains
final result = repository
    .getUser(id)
    .then((user) => user.updateProfile())
    .catchError((error) => handleError(error));
```

## üß™ Advanced Testing Patterns

### BLoC Testing with States

```dart
// ‚úÖ CORRECT: Comprehensive BLoC testing
blocTest<UserCubit, UserState>(
  'emits [UserLoading, UserSuccess] when user is fetched successfully',
  build: () => UserCubit(repository: mockRepository),
  setUp: () {
    when(() => mockRepository.getUser(any()))
        .thenAnswer((_) async => mockUser);
  },
  act: (cubit) => cubit.fetchUser('123'),
  expect: () => [
    const UserLoading(),
    UserSuccess(mockUser),
  ],
  verify: (_) {
    verify(() => mockRepository.getUser('123')).called(1);
  },
);
```

### Widget Testing with Mocks

```dart
// ‚úÖ CORRECT: Widget test with proper mocking
testWidgets('should display user name when loaded', (tester) async {
  when(() => mockUserCubit.state).thenReturn(UserSuccess(mockUser));

  await tester.pumpWidget(
    MaterialApp(
      home: BlocProvider<UserCubit>.value(
        value: mockUserCubit,
        child: const UserProfilePage(),
      ),
    ),
  );

  expect(find.text(mockUser.name), findsOneWidget);
});
```

## üîê Security & Validation Rules

### Input Sanitization

```dart
// ‚ùå SECURITY RISK: Direct user input usage
void updateUser(String email, String name) {
  // Direct usage without validation
  user.email = email;
}

// ‚úÖ SECURE: Proper validation
void updateUser(String email, String name) {
  if (!isValidEmail(email)) {
    throw InvalidEmailException(email);
  }
  if (name.trim().isEmpty) {
    throw EmptyNameException();
  }

  user.email = email.trim().toLowerCase();
  user.name = name.trim();
}
```

### Environment Variable Usage

```dart
// ‚ùå WRONG: Direct environment access
final apiUrl = Platform.environment['API_URL'] ?? 'fallback';

// ‚úÖ CORRECT: Use environment configuration factory
final apiUrl = EnvConfigFactory.apiUrl;
```

## üì± Flutter-Specific Performance Rules

### Widget Optimization Patterns

```dart
// ‚ùå PERFORMANCE ISSUE: Creating widgets in build method
@override
Widget build(BuildContext context) {
  final button = ElevatedButton(
    onPressed: () => increment(),
    child: const Text('Increment'),
  );
  return button;
}

// ‚úÖ OPTIMIZED: Static widgets or proper separation
class IncrementButton extends StatelessWidget {
  const IncrementButton({super.key, required this.onPressed});

  final VoidCallback onPressed;

  @override
  Widget build(BuildContext context) {
    return ElevatedButton(
      onPressed: onPressed,
      child: const Text('Increment'),
    );
  }
}
```

### State Management Optimization

```dart
// ‚ùå INEFFICIENT: Rebuilding entire widget tree
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return BlocBuilder<CounterCubit, int>(
      builder: (context, count) {
        return Scaffold(
          appBar: AppBar(title: Text('Counter: $count')),
          body: Column(children: [
            Text('Current count: $count'),
            ElevatedButton(
              onPressed: () => context.read<CounterCubit>().increment(),
              child: const Text('Increment'),
            ),
          ]),
        );
      },
    );
  }
}

// ‚úÖ OPTIMIZED: Selective rebuilds
class CounterPage extends StatelessWidget {
  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        title: BlocBuilder<CounterCubit, int>(
          builder: (context, count) => Text('Counter: $count'),
        ),
      ),
      body: Column(children: [
        const CounterText(), // Only rebuilds when count changes
        const IncrementButton(), // Never rebuilds
      ]),
    );
  }
}
```

## üèóÔ∏è Architecture Patterns

### Repository Pattern Implementation

```dart
// ‚úÖ CORRECT: Repository with proper error handling
abstract class UserRepository {
  Future<User> getUser(String id);
  Future<void> updateUser(User user);
  Future<void> deleteUser(String id);
}

class UserRepositoryImpl implements UserRepository {
  const UserRepositoryImpl({
    required this.apiClient,
    required this.localDatabase,
  });

  final ApiClient apiClient;
  final LocalDatabase localDatabase;

  @override
  Future<User> getUser(String id) async {
    try {
      // Try local first, then remote
      final localUser = await localDatabase.getUser(id);
      if (localUser != null) return localUser;

      final remoteUser = await apiClient.getUser(id);
      await localDatabase.saveUser(remoteUser);
      return remoteUser;
    } on NetworkException {
      // Return cached version if available
      final cachedUser = await localDatabase.getUser(id);
      if (cachedUser != null) return cachedUser;
      rethrow;
    }
  }
}
```

### Factory Pattern for Environment Configuration

```dart
// ‚úÖ CORRECT: Environment factory with sealed classes
sealed class Environment {
  const Environment();
  static Environment get current => _getCurrentEnvironment();

  String get apiUrl;
  String get appName;
  bool get isDebugMode;
}

final class Development extends Environment {
  const Development();
  @override String get apiUrl => EnvDev.apiUrl;
  @override String get appName => EnvDev.appName;
  @override bool get isDebugMode => EnvDev.isDebugMode;
}
```

## üéØ Linus Philosophy Applied

> "Bad programmers worry about the code. Good programmers worry about data structures and their relationships."

### Never Use Band-Aid Solutions

**NEVER** suppress linter warnings with ignore directives unless absolutely necessary:

```dart
// ‚ùå BAD: Band-aid solution
// ignore_for_file: avoid_print
// ignore: cascade_invocations

// ‚úÖ GOOD: Fix the root cause
Logger(printer: SimplePrinter())
  ..info('Process started')
  ..info('Configuration loaded');
```

### Root Cause Analysis Process

1. **Identify**: Why is the linter complaining?
2. **Design**: What's the proper abstraction?
3. **Implement**: Clean solution that eliminates the issue
4. **Verify**: No warnings, better architecture

### Console Output Best Practices

For CLI tools, implement proper console abstraction:

```dart
/// Console output helper for CLI tools
class Console {
  /// Write success message to stdout
  static void success(String message) => stdout.writeln(message);

  /// Write info message to stdout
  static void info(String message) => stdout.writeln(message);

  /// Write error message to stderr
  static void error(String message) => stderr.writeln(message);

  /// Write warning message to stderr
  static void warning(String message) => stderr.writeln(message);
}

// ‚úÖ USAGE: Proper stream separation
Console.success('‚úÖ Validation passed');
Console.error('‚ùå Error occurred');
```

Remember: **Readability and consistency are more important than cramming code into fewer lines.**

## üö® Zero Tolerance Issues

These MUST be fixed immediately:

1. **Missing documentation** on public APIs
2. **cascade_invocations** warnings
3. **lines_longer_than_80_chars** errors
4. **avoid_catches_without_on_clauses** - missing `on` clause in catch blocks
5. **avoid_print** in production code
6. **deprecated_member_use** warnings (Color.value, Color.alpha)
7. **Missing const** constructors
8. **Unused imports**
9. **unused_field** warnings
10. **unnecessary_underscores** in parameter names
11. **unnecessary_statements** and dead code
12. **depend_on_referenced_packages** - missing dependencies
13. **Memory leaks** (undisposed resources)
14. **Security vulnerabilities** (unvalidated input)
15. **Performance anti-patterns** (unnecessary rebuilds)
16. **Architecture violations** (direct environment access)

## üìã Quick Reference: Error ‚Üí Solution (Copy-Paste Ready)

| **Linter Error**                            | **1-Second Fix**        | **Copy-Paste Solution**                                               |
| ------------------------------------------- | ----------------------- | --------------------------------------------------------------------- |
| `public_member_api_docs`                    | Add doc comment         | `/// Implementation of [Repository].`                                 |
| `cascade_invocations` (static)              | Group with records      | `final _ = (Factory.a, Factory.b, Factory.c);`                        |
| `cascade_invocations` (instance)            | Use cascade             | `logger..info('A')..info('B')..info('C');`                            |
| `lines_longer_than_80_chars`                | Break at comma/operator | `group(`<br/>&nbsp;&nbsp;`'Long description',`<br/>&nbsp;&nbsp;`() {` |
| `lines_longer_than_80_chars` (comments)     | Break comment lines     | `// Long comment text`<br/>`// continued here`                        |
| `avoid_catches_without_on_clauses`          | Add `on` clause         | `} on SpecificException catch (e) {`                                  |
| `omit_local_variable_types`                 | Replace type with `var` | `for (var i = 0; i < 10; i++)`                                        |
| `prefer_const_constructors`                 | Add `const` keyword     | `const Text('Hello')`                                                 |
| `avoid_print`                               | Use Console abstraction | `Console.info('message')`                                             |
| `deprecated_member_use` (Color.value)       | Use toARGB32()          | `expect(color.toARGB32(), equals(0xFF2196F3))`                        |
| `deprecated_member_use` (Color.alpha)       | Use component accessor  | `expect((color.a * 255.0).round() & 0xff, equals(255))`               |
| `unnecessary_lambdas`                       | Use tear-off            | `items.map(Object.toString)`                                          |
| `prefer_final_locals`                       | Change to `final`       | `final message = 'Hello';`                                            |
| `unused_field`                              | Remove or use field     | Remove field or use in methods                                        |
| `unnecessary_underscores`                   | Use single underscore   | `when(success: (_) => true, error: (_) => false)`                     |
| `unnecessary_statements`                    | Assign to `_` variable  | `final _ = unusedVariable;`                                           |
| `depend_on_referenced_packages`             | Add to pubspec.yaml     | Add missing package to dependencies                                   |
| `invalid_use_of_visible_for_testing_member` | Add ignore comment      | `// ignore: invalid_use_of_visible_for_testing_member`                |

**‚ö° Speed Commands:**

```bash
dart format lib/ test/ --set-exit-if-changed  # Fix formatting
dart analyze --fatal-infos                    # See all errors
dart fix --apply                              # Auto-fix some issues
```

## üéØ Error Prevention Checklist

**Before committing, verify:**

- [ ] All public classes/methods have `/// documentation`
- [ ] Multiple static calls grouped with records `()`
- [ ] Multiple instance calls use cascade `..`
- [ ] No lines exceed 80 characters
- [ ] Use `var` instead of explicit types for obvious cases
- [ ] All constructors that can be `const` are marked `const`
- [ ] No `print()` statements in production code

Following these guidelines ensures clean, maintainable code that passes all linter checks with zero warnings or errors.

## üåê English Language Requirements - MANDATORY

### üìù **ZERO TOLERANCE: English Only for All Content**

**CRITICAL RULE**: All code, documentation, comments, markdown files, and any written content MUST be in English only. This is mandatory for spell check compliance and professional standards.

#### **üö´ What Must Be English**

**1. Code Documentation & Comments:**

```dart
// ‚ùå WRONG: Vietnamese documentation
/// Qu·∫£n l√Ω tr·∫°ng th√°i ƒë·∫øm s·ªë v·ªõi c√°c ph∆∞∆°ng th·ª©c tƒÉng gi·∫£m
class CounterCubit extends Cubit<int> {
  /// T·∫°o instance v·ªõi gi√° tr·ªã ban ƒë·∫ßu l√† 0
  CounterCubit() : super(0);

  /// TƒÉng gi√° tr·ªã l√™n 1 ƒë∆°n v·ªã
  void increment() => emit(state + 1); // TƒÉng s·ªë l√™n
}

// ‚úÖ CORRECT: English documentation
/// Manages counter state with increment and decrement operations.
class CounterCubit extends Cubit<int> {
  /// Creates a CounterCubit with initial state of 0.
  CounterCubit() : super(0);

  /// Increments the counter value by 1.
  void increment() => emit(state + 1); // Increment the value
}
```

**2. Error Messages & Exceptions:**

```dart
// ‚ùå WRONG: Vietnamese error messages
throw Exception('L·ªói khi t·∫£i c·∫•u h√¨nh m√¥i tr∆∞·ªùng');
throw ConfigException('Kh√¥ng t√¨m th·∫•y file .env');

// ‚úÖ CORRECT: English error messages
throw Exception('Failed to load environment configuration');
throw ConfigException('Environment file .env not found');
```

**3. Test Descriptions:**

```dart
// ‚ùå WRONG: Vietnamese test descriptions
test('n√™n tr·∫£ v·ªÅ gi√° tr·ªã ƒë√∫ng khi g·ªçi apiUrl', () {
  // test implementation
});

group('Ki·ªÉm tra repository implementation', () {
  // tests
});

// ‚úÖ CORRECT: English test descriptions
test('should return correct value when calling apiUrl', () {
  // test implementation
});

group('Repository implementation tests', () {
  // tests
});
```

**4. Variable & Method Names:**

```dart
// ‚ùå WRONG: Vietnamese naming
final tenUngDung = 'My App';
void capNhatNguoiDung() {}
class QuanLyNguoiDung {}

// ‚úÖ CORRECT: English naming
final appName = 'My App';
void updateUser() {}
class UserManager {}
```

**5. Markdown Documentation:**

```markdown
‚ùå WRONG: Vietnamese markdown

# H∆∞·ªõng D·∫´n C√†i ƒê·∫∑t

## T·ªïng Quan D·ª± √Ån

D·ª± √°n n√†y s·ª≠ d·ª•ng Flutter ƒë·ªÉ ph√°t tri·ªÉn...

‚úÖ CORRECT: English markdown

# Installation Guide

## Project Overview

This project uses Flutter to develop...
```

#### **‚úÖ English Compliance Checklist**

Before any commit, verify:

- [ ] **All class/method documentation** uses English `/// comments`
- [ ] **All inline comments** are in English
- [ ] **All variable names** use English terminology
- [ ] **All method names** use English terminology
- [ ] **All error messages** are in English
- [ ] **All test descriptions** are in English
- [ ] **All markdown files** are in English
- [ ] **All README content** is in English
- [ ] **All commit messages** are in English (conventional commits)

#### **üõ†Ô∏è Spell Check Integration**

Our cspell configuration (`cspell.json`) enforces English-only:

```json
{
  "language": "en",
  "dictionaries": ["vgv_allowed", "vgv_forbidden"]
}
```

**When spell check fails:**

1. ‚úÖ Convert non-English content to proper English
2. ‚úÖ Add technical terms to `cspell.json` words array if needed
3. ‚ùå NEVER suppress spell check with ignore directives

#### **üéØ Common Vietnamese ‚Üí English Translations**

| Vietnamese Term | English Term    | Usage Context        |
| --------------- | --------------- | -------------------- |
| `t·∫°o`           | `create`        | Method names         |
| `c·∫≠p nh·∫≠t`      | `update`        | Method names         |
| `x√≥a`           | `delete`        | Method names         |
| `t√¨m ki·∫øm`      | `search`        | Method names         |
| `l·∫•y`           | `get`           | Method names         |
| `c·∫•u h√¨nh`      | `configuration` | Class/variable names |
| `qu·∫£n l√Ω`       | `manager`       | Class names          |
| `d·ªãch v·ª•`       | `service`       | Class names          |
| `kho l∆∞u tr·ªØ`   | `repository`    | Class names          |
| `m√¥i tr∆∞·ªùng`    | `environment`   | General usage        |
| `·ª©ng d·ª•ng`      | `application`   | General usage        |
| `ng∆∞·ªùi d√πng`    | `user`          | General usage        |

#### **üö® Pre-Commit English Validation**

During vibe coding, run these commands to ensure English compliance:

```bash
# 1. Spell check all markdown files
npx cspell doc/**/*.md README.md --no-progress

# 2. Analyze code for linting (includes comment validation)
make analyze

# 3. Format code consistently
make format

# 4. Complete validation pipeline
make pre-commit  # Must pass for English compliance
```

#### **üìö English Documentation Standards**

**Class Documentation Template:**

````dart
/// Brief description of what the class does.
///
/// Longer description with more details about the class purpose,
/// usage patterns, and any important considerations.
///
/// Example:
/// ```dart
/// final manager = UserManager();
/// final user = await manager.getUser('123');
/// ```
class UserManager {
  /// Brief description of what the method does.
  ///
  /// [parameter] Description of the parameter.
  /// Returns description of what the method returns.
  Future<User> getUser(String userId) async {
    // Implementation
  }
}
````

**Test Documentation Template:**

```dart
group('UserManager', () {
  group('getUser', () {
    test('should return user when valid ID is provided', () {
      // Test implementation
    });

    test('should throw UserNotFoundException when user does not exist', () {
      // Test implementation
    });

    test('should handle network errors gracefully', () {
      // Test implementation
    });
  });
});
```

#### **üí° Best Practices for English Content**

1. **Use Active Voice**: "The method returns a value" vs "A value is returned"
2. **Be Concise**: Clear and direct explanations
3. **Use Standard Terms**: Follow Flutter/Dart naming conventions
4. **Consistent Terminology**: Use the same English terms throughout
5. **Professional Tone**: Write as if for international developers

#### **üîß Editor Configuration for English**

**VS Code Settings (`.vscode/settings.json`):**

```json
{
  "cSpell.language": "en",
  "cSpell.enabled": true,
  "cSpell.diagnosticLevel": "Error",
  "dart.documentation": "full",
  "editor.codeActionsOnSave": {
    "source.fixAll": "explicit"
  }
}
```

### üöÄ Vibe Coding English Protocol

#### **Real-Time Validation During Coding:**

```bash
# After writing any documentation or comments
make analyze              # Check for linting issues

# After creating markdown files
npx cspell [filename].md --no-progress  # Verify English content

# After adding error messages or strings
make format               # Ensure formatting compliance
```

#### **Emergency English Fixes:**

```bash
# When spell check fails in CI
npx cspell doc/**/*.md --list-files  # Find problematic files
# Convert content to English and re-commit

# When linting fails due to comments
dart analyze --fatal-infos         # See specific issues
# Fix non-English comments and re-run
```

**ZERO TOLERANCE POLICY**: Any non-English content will cause spell check failures in CI/CD. Always write in English from the start to avoid rework and failed builds.

## üöÄ Vibe Coding Workflow - Mandatory Command Execution

**CRITICAL RULE**: During any coding session, these commands MUST be executed to prevent linting errors, warnings, and test failures. This is non-negotiable for code quality.

### üéØ Pre-Coding Checklist (ALWAYS RUN)

Before making ANY code changes, execute:

```bash
# 1. Quick health check
make check                     # Format + analyze (fast)

# 2. Verify tests are working
make test                      # Run all tests

# 3. Optional: Check coverage if working on new features
make test-coverage            # Run tests with coverage
```

### üîß During Coding (After Each Significant Change)

After writing code, immediately run:

```bash
# Quick validation (run frequently)
make format           # Auto-fix formatting
make analyze          # Check for issues
flutter test --dart-define=ENVIRONMENT=development  # Quick test
```

**Makefile Shortcuts:**

```bash
make format                   # Format code
make analyze                  # Analyze code
make test                     # Run tests
```

### ‚úÖ Pre-Commit (MANDATORY)

Before committing, ALWAYS run:

```bash
# Complete validation pipeline
make pre-commit               # Format + analyze + test

# OR use individual commands
make check                    # Format + analyze only
make test                     # Verify tests pass

# Full CI equivalent (recommended)
make local-ci                 # Complete pipeline
```

### üõ°Ô∏è Error Prevention Strategy

#### **Level 1: Automatic Prevention (Lefthook)**

```yaml
# These run automatically via lefthook.yml
- pre-commit: Format, analyze, test
- pre-push: Full CI pipeline
- commit-msg: Conventional commit validation
```

#### **Level 2: Manual Validation (Required)**

```bash
# Before starting work
make check && make test

# During development (after each change)
make format && make analyze

# Before committing (mandatory)
make pre-commit

# Before pushing (ultimate validation)
make local-ci
```

#### **Level 3: Environment-Specific Testing**

```bash
# Test all environments
make generate-env-dev && make test
make generate-env-staging && make test
make generate-env-prod && make test
```

### üö® Critical Command Reference

| **Phase**       | **Required Commands**          | **Purpose**           |
| --------------- | ------------------------------ | --------------------- |
| **Pre-Work**    | `make check` + `make test`     | Ensure clean baseline |
| **During Work** | `make format` + `make analyze` | Continuous validation |
| **Pre-Commit**  | `make pre-commit`              | Complete validation   |
| **Pre-Push**    | `make local-ci`                | Full CI pipeline      |

### üé® Tool Integration Hierarchy

#### **1. Makefile Commands (Primary)**

```bash
# GitHub Actions equivalent
make local-ci                 # Complete CI pipeline
make check                    # Quick development check
make test-coverage           # Coverage with HTML report
make format                  # Format only
make analyze                 # Analyze only
make test                    # Test only
```

#### **3. Lefthook (Automatic)**

```bash
# Automatic execution
git commit                   # Triggers pre-commit hooks
git push                     # Triggers pre-push hooks
```

### ‚ö° Emergency Commands (When Things Break)

#### **When Linting Fails:**

```bash
make format                  # Fix formatting issues
dart analyze --fatal-infos   # See specific errors
dart fix --apply             # Auto-fix some issues
```

#### **When Tests Fail:**

```bash
flutter clean && flutter pub get    # Reset environment
make generate-env-dev               # Regenerate environment
flutter test --dart-define=ENVIRONMENT=development
```

#### **When Coverage Drops:**

```bash
make test-coverage          # Generate coverage report
make coverage-open          # View HTML report
# Add tests for uncovered code
```

### üéØ Vibe Coding Success Metrics

**Zero Tolerance Indicators:**

- ‚ùå No linting errors or warnings
- ‚ùå No test failures
- ‚ùå No formatting inconsistencies
- ‚ùå No missing documentation
- ‚ùå No license compliance issues

**Success Indicators:**

- ‚úÖ All commands execute without errors
- ‚úÖ Coverage maintains or improves
- ‚úÖ Git hooks pass automatically
- ‚úÖ CI pipeline ready (make local-ci passes)

---

## üñºÔ∏è Image Asset Management - Pure Flutter Approach

**THE GOLDEN RULE:** Use the established Image Asset service with dependency injection for consistent, responsive, and error-safe image handling.

### Service Injection Pattern - MANDATORY

```dart
// ‚ùå WRONG: Direct widget usage without service layer
Widget buildImage() {
  return Image.asset(
    'assets/images/logo.png',
    width: 100,
    height: 100,
  );
}

// ‚úÖ CORRECT: Use AssetImageService with dependency injection
class ProfileWidget extends StatelessWidget {
  const ProfileWidget({super.key});

  @override
  Widget build(BuildContext context) {
    final assetService = GetIt.instance<AssetImageService>();
    final appImages = GetIt.instance<AppImages>();
    
    return assetService.assetImage(
      appImages.employeeAvatar,
      width: 96,  // Automatically becomes 96.w (responsive)
      height: 96, // Automatically becomes 96.h (responsive)
      fit: BoxFit.cover,
    );
  }
}
```

### Asset Path Management - CENTRALIZED

```dart
// ‚ùå WRONG: Magic strings scattered throughout code
Widget buildSplashLogo() {
  return Image.asset('assets/images/splash/logo.png');
}

Widget buildLoginLogo() {
  return Image.asset('assets/images/login/logo.png');
}

// ‚úÖ CORRECT: Use AppImages constants for type safety
class SplashPage extends StatelessWidget {
  const SplashPage({super.key});

  @override
  Widget build(BuildContext context) {
    final assetService = GetIt.instance<AssetImageService>();
    final appImages = GetIt.instance<AppImages>();
    
    return assetService.assetImage(
      appImages.splashLogo,  // Type-safe, centralized path
      width: appImages.imageSizes.large,  // Consistent sizing
    );
  }
}
```

### Error Handling - DEFENSIVE PROGRAMMING

```dart
// ‚ùå WRONG: No error handling, might crash on missing assets
Widget buildUserAvatar() {
  return Image.asset(
    userAvatarPath,
    width: 50,
    height: 50,
  );
}

// ‚úÖ CORRECT: Built-in error handling with graceful fallbacks
Widget buildUserAvatar() {
  final assetService = GetIt.instance<AssetImageService>();
  
  return assetService.assetImage(
    userAvatarPath,
    width: 50,  // Auto-responsive with .w
    height: 50, // Auto-responsive with .h
    // Automatic error handling: shows Icons.broken_image if asset fails
    // Automatic loading states: shows CircularProgressIndicator while loading
  );
}

// For custom error states
Widget buildCriticalImage() {
  return assetService.assetImage(
    criticalImagePath,
    width: 100,
    height: 100,
    errorWidget: const Icon(Icons.error_outline, color: Colors.red),
    placeholder: const ShimmerPlaceholder(),
  );
}
```

### Responsive Sizing - AUTOMATIC

```dart
// ‚ùå WRONG: Fixed pixel values, not responsive
Widget buildIcon() {
  return Image.asset(
    'assets/icon.png',
    width: 24,    // Fixed pixels - bad for different screen sizes
    height: 24,
  );
}

// ‚úÖ CORRECT: Let service handle responsive sizing automatically
Widget buildIcon() {
  final assetService = GetIt.instance<AssetImageService>();
  final appImages = GetIt.instance<AppImages>();
  
  return assetService.assetImage(
    appImages.commonIcon,
    width: 24,    // Automatically becomes 24.w (responsive)
    height: 24,   // Automatically becomes 24.h (responsive)
  );
}

// Use predefined sizes for consistency
Widget buildStandardSizes() {
  final appImages = GetIt.instance<AppImages>();
  
  return Column(
    children: [
      // Small: 48.0
      assetService.assetImage(icon, width: appImages.imageSizes.small),
      // Medium: 96.0  
      assetService.assetImage(icon, width: appImages.imageSizes.medium),
      // Large: 144.0
      assetService.assetImage(icon, width: appImages.imageSizes.large),
      // Extra Large: 192.0
      assetService.assetImage(icon, width: appImages.imageSizes.xLarge),
    ],
  );
}
```

### Performance Optimization - BUILT-IN CACHING

```dart
// ‚ùå WRONG: Manual cache management
Widget buildOptimizedImage() {
  return Image.asset(
    imagePath,
    cacheWidth: 100,
    cacheHeight: 100,
  );
}

// ‚úÖ CORRECT: Service handles caching automatically
Widget buildOptimizedImage() {
  final assetService = GetIt.instance<AssetImageService>();
  
  return assetService.assetImage(
    imagePath,
    width: 100,   // Service automatically sets cacheWidth: 100
    height: 100,  // Service automatically sets cacheHeight: 100
    // Built-in ImageCache optimization included
  );
}
```

### Testing Pattern - 100% COVERAGE

```dart
// Test the service behavior, not just widget rendering
testWidgets('should handle error states with default fallback', (
  tester,
) async {
  final service = const AssetImageServiceImpl();
  
  await tester.pumpWidget(
    MaterialApp(
      home: Builder(
        builder: (context) {
          ScreenUtil.init(context, designSize: const Size(375, 812));
          return service.assetImage('assets/images/nonexistent.png');
        },
      ),
    ),
  );

  await tester.pumpAndSettle();
  
  // Verify error fallback appears
  expect(find.byIcon(Icons.broken_image), findsOneWidget);
  
  // Verify default size is applied
  final iconWidget = tester.widget<Icon>(find.byIcon(Icons.broken_image));
  expect(iconWidget.size, equals(24.w));
});
```

---

## üé® Design System & Styling - Comprehensive Approach

**THE GOLDEN RULE:** Use the established Design System services with dependency injection for consistent, maintainable, and type-safe styling across the application.

### Color System Usage - MANDATORY PATTERNS

```dart
// ‚ùå WRONG: Hard-coded colors scattered throughout code
Widget buildButton() {
  return ElevatedButton(
    style: ElevatedButton.styleFrom(
      backgroundColor: Color(0xFFFF6B35), // Magic number - unmaintainable
      foregroundColor: Colors.white,      // Generic color - inconsistent
    ),
    onPressed: () {},
    child: Text('Button'),
  );
}

// ‚úÖ CORRECT: Use AppColors service with semantic naming
class BrandButton extends StatelessWidget {
  const BrandButton({super.key});

  @override
  Widget build(BuildContext context) {
    final appColors = GetIt.instance<AppColors>();
    
    return ElevatedButton(
      style: ElevatedButton.styleFrom(
        backgroundColor: appColors.amberNormal,    // Semantic brand color
        foregroundColor: appColors.charcoal,      // Consistent text color
      ),
      onPressed: () {},
      child: Text('Brand Button'),
    );
  }
}
```

### Interactive State Management - REQUIRED PATTERN

```dart
// ‚ùå WRONG: No interaction states, poor UX
Widget buildInteractiveCard() {
  return Container(
    color: Colors.grey[200], // Static color - no interaction feedback
    child: Text('Card'),
  );
}

// ‚úÖ CORRECT: Proper interaction states with design system
class InteractiveCard extends StatefulWidget {
  const InteractiveCard({super.key});

  @override
  State<InteractiveCard> createState() => _InteractiveCardState();
}

class _InteractiveCardState extends State<InteractiveCard> {
  bool _isHovered = false;
  bool _isPressed = false;

  @override
  Widget build(BuildContext context) {
    final appColors = GetIt.instance<AppColors>();
    
    // Use design system hover/active states
    final cardColor = switch ((_isPressed, _isHovered)) {
      (true, _) => appColors.amberLightActive,    // Active state
      (false, true) => appColors.amberLightHover, // Hover state
      (false, false) => appColors.amberLight,     // Default state
    };
    
    return MouseRegion(
      onEnter: (_) => setState(() => _isHovered = true),
      onExit: (_) => setState(() => _isHovered = false),
      child: GestureDetector(
        onTapDown: (_) => setState(() => _isPressed = true),
        onTapUp: (_) => setState(() => _isPressed = false),
        onTapCancel: () => setState(() => _isPressed = false),
        child: Container(
          color: cardColor,
          child: Text('Interactive Card'),
        ),
      ),
    );
  }
}
```

### Typography System - TYPE-SAFE APPROACH

```dart
// ‚ùå WRONG: Inconsistent text styles scattered everywhere
Widget buildTextContent() {
  return Column(
    children: [
      Text('Title', style: TextStyle(fontSize: 24, fontWeight: FontWeight.bold)),
      Text('Body', style: TextStyle(fontSize: 16)),
      Text('Caption', style: TextStyle(fontSize: 12, color: Colors.grey)),
    ],
  );
}

// ‚úÖ CORRECT: Use AppTextStyles service for consistency
class TextContent extends StatelessWidget {
  const TextContent({super.key});

  @override
  Widget build(BuildContext context) {
    final appTextStyles = GetIt.instance<AppTextStyles>();
    final appColors = GetIt.instance<AppColors>();
    
    return Column(
      crossAxisAlignment: CrossAxisAlignment.start,
      children: [
        Text('Main Title', style: appTextStyles.displayLarge()),
        Text('Section Header', style: appTextStyles.headingLarge()),
        Text('Primary content goes here', style: appTextStyles.bodyLarge()),
        Text('Secondary information', style: appTextStyles.bodyMedium()),
        Text(
          'Fine print details', 
          style: appTextStyles.caption(color: appColors.greyNormal),
        ),
      ],
    );
  }
}
```

### Responsive Sizing - AUTOMATIC SCALING

```dart
// ‚ùå WRONG: Fixed pixel values, not responsive
Widget buildLayout() {
  return Container(
    width: 120,        // Fixed pixels - bad for different screen sizes
    height: 80,        // Fixed pixels - poor responsive design
    padding: EdgeInsets.all(16),
    margin: EdgeInsets.symmetric(horizontal: 20, vertical: 12),
  );
}

// ‚úÖ CORRECT: Use AppSizes service for responsive design
class ResponsiveLayout extends StatelessWidget {
  const ResponsiveLayout({super.key});

  @override
  Widget build(BuildContext context) {
    final appSizes = GetIt.instance<AppSizes>();
    
    return Container(
      width: appSizes.r120,     // Responsive both dimensions
      height: appSizes.v80,     // Responsive height only
      padding: EdgeInsets.all(appSizes.r16),  // Responsive padding
      margin: EdgeInsets.symmetric(
        horizontal: appSizes.h20,  // Responsive horizontal margin
        vertical: appSizes.v12,    // Responsive vertical margin
      ),
      decoration: BoxDecoration(
        borderRadius: BorderRadius.circular(appSizes.borderRadiusMd),
      ),
    );
  }
}
```

### Theme Integration - LIGHT/DARK MODE SUPPORT

```dart
// ‚ùå WRONG: Hard-coded theme colors, no dark mode support
Widget buildThemedContent() {
  return Container(
    color: Colors.white,        // Fixed color - no theme support
    child: Text(
      'Content',
      style: TextStyle(color: Colors.black),  // Fixed text color
    ),
  );
}

// ‚úÖ CORRECT: Use theme extensions for automatic theme switching
class ThemedContent extends StatelessWidget {
  const ThemedContent({super.key});

  @override
  Widget build(BuildContext context) {
    final appTextStyles = GetIt.instance<AppTextStyles>();
    final colorExtension = context.theme.extension<AppColorExtension>()!;
    
    return Container(
      color: colorExtension.primary,      // Automatically switches with theme
      child: Text(
        'Themed Content',
        style: appTextStyles.bodyLarge(
          color: colorExtension.textPrimary,  // Theme-aware text color
        ),
      ),
    );
  }
}
```

### Complete Color Palette Usage - SEMANTIC APPROACH

```dart
// ‚ùå WRONG: Generic color choices without semantic meaning
Widget buildStatusIndicators() {
  return Row(
    children: [
      Container(color: Colors.green, width: 20, height: 20),    // Generic
      Container(color: Colors.red, width: 20, height: 20),      // Generic  
      Container(color: Colors.blue, width: 20, height: 20),     // Generic
    ],
  );
}

// ‚úÖ CORRECT: Semantic color usage with design system
class StatusIndicators extends StatelessWidget {
  const StatusIndicators({super.key});

  @override
  Widget build(BuildContext context) {
    final appColors = GetIt.instance<AppColors>();
    final appSizes = GetIt.instance<AppSizes>();
    
    return Row(
      children: [
        // Success state - semantic color choice
        Container(
          color: appColors.greenNormal,
          width: appSizes.r20,
          height: appSizes.r20,
        ),
        SizedBox(width: appSizes.h8),
        
        // Error state - semantic color choice
        Container(
          color: appColors.redNormal,
          width: appSizes.r20,
          height: appSizes.r20,
        ),
        SizedBox(width: appSizes.h8),
        
        // Information state - semantic color choice
        Container(
          color: appColors.blueNormal,
          width: appSizes.r20,
          height: appSizes.r20,
        ),
      ],
    );
  }
}
```

### Testing Pattern - DESIGN SYSTEM VALIDATION

```dart
// Test design system consistency and integration
testWidgets('should use design system colors consistently', (tester) async {
  final appColors = const AppColorsImpl();
  
  await tester.pumpWidget(
    MaterialApp(
      home: Scaffold(
        body: ElevatedButton(
          style: ElevatedButton.styleFrom(
            backgroundColor: appColors.amberNormal,
          ),
          onPressed: () {},
          child: Text('Test Button'),
        ),
      ),
    ),
  );

  expect(find.byType(ElevatedButton), findsOneWidget);
  
  final button = tester.widget<ElevatedButton>(find.byType(ElevatedButton));
  final buttonStyle = button.style!;
  
  // Verify design system color is applied correctly
  expect(
    buttonStyle.backgroundColor!.resolve({}),
    equals(appColors.amberNormal),
  );
});

// Test responsive sizing integration
testWidgets('should apply responsive sizing correctly', (tester) async {
  final appSizes = AppSizesImpl();
  
  await tester.pumpWidget(
    MaterialApp(
      home: Builder(
        builder: (context) {
          ScreenUtil.init(context, designSize: const Size(375, 812));
          return Container(
            width: appSizes.r100,   // Should be 100.w
            height: appSizes.v80,   // Should be 80.h
            child: Text('Responsive Container'),
          );
        },
      ),
    ),
  );

  expect(find.byType(Container), findsOneWidget);
  expect(find.text('Responsive Container'), findsOneWidget);
});
```

---

### üìã Daily Workflow Template

```bash
# 1. Start of day
git pull
make check && make test

# 2. During development (after each feature/fix)
make format
make analyze
flutter test

# 3. Before committing
make pre-commit

# 4. Before pushing
make local-ci

# 5. End of day verification
make test-coverage
make coverage-open  # Verify coverage
```

### üî• Emergency Workflow (When Under Pressure)

```bash
# Minimum viable commands (never skip these)
make format                   # 1. Fix formatting
make analyze                  # 2. Check for errors
flutter test                  # 3. Verify tests pass

# If time allows
make pre-commit               # Complete validation
```

### üèÜ Advanced Vibe Coding (Performance Mode)

```bash
# Parallel execution for speed
make format & make analyze & wait

# Environment-specific rapid testing
flutter test --dart-define=ENVIRONMENT=development --coverage

# Continuous validation during development
watch -n 30 'make check'  # Auto-check every 30 seconds
```

**Remember**: These commands are your safety net. Running them religiously prevents the majority of CI failures and maintains code quality standards. Make them muscle memory!
